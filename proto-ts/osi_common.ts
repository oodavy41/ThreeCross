// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "osi_common.proto" (package "osi3", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 *
 * \brief A cartesian 3D vector for positions, velocities or accelerations or
 * its uncertainties.
 *
 * The coordinate system is defined as right-handed.
 *
 * Units are m for positions, m/s for velocities, and m/s^2 for
 * accelerations.
 *
 *
 * @generated from protobuf message osi3.Vector3d
 */
export interface Vector3d {
    /**
     * The x-coordinate.
     *
     * Unit: m, m/s, or m/s^2
     *
     *
     * @generated from protobuf field: optional double x = 1;
     */
    x?: number;
    /**
     * The y-coordinate.
     *
     * Unit: m, m/s, or m/s^2
     *
     *
     * @generated from protobuf field: optional double y = 2;
     */
    y?: number;
    /**
     * The z-coordinate.
     *
     * Unit: m, m/s, or m/s^2
     *
     *
     * @generated from protobuf field: optional double z = 3;
     */
    z?: number;
}
/**
 *
 * \brief A cartesian 2D vector for positions, velocities or accelerations or
 * its uncertainties.
 *
 * Units are m for positions, m/s for velocities, and m/s^2 for
 * accelerations.
 *
 *
 * @generated from protobuf message osi3.Vector2d
 */
export interface Vector2d {
    /**
     * The x-coordinate.
     *
     * Unit: m, m/s, or m/s^2
     *
     *
     * @generated from protobuf field: optional double x = 1;
     */
    x?: number;
    /**
     * The y-coordinate.
     *
     * Unit: m, m/s, or m/s^2
     *
     *
     * @generated from protobuf field: optional double y = 2;
     */
    y?: number;
}
/**
 *
 * \brief A timestamp.
 *
 * Names and types of fields are chosen in accordance to
 * google/protobuf/timestamp.proto to allow a possible switch in the future.
 * There is no definition of the zero point in time neither it is the Unix
 * epoch. A simulation may start at the zero point in time but it is not
 * mandatory.
 *
 *
 * @generated from protobuf message osi3.Timestamp
 */
export interface Timestamp {
    /**
     * The number of seconds since the start of e.g. the simulation / system /
     * vehicle.
     *
     * Unit: s
     *
     * \rules
     * is_greater_than_or_equal_to: 0
     * \endrules
     *
     *
     * @generated from protobuf field: optional int64 seconds = 1;
     */
    seconds?: bigint;
    /**
     * The number of nanoseconds since the start of the last second.
     *
     * Range: [0, 999.999.999]
     *
     * Unit: ns
     *
     * \rules
     * is_greater_than_or_equal_to: 0
     * is_less_than_or_equal_to: 999999999
     * \endrules
     *
     *
     * @generated from protobuf field: optional uint32 nanos = 2;
     */
    nanos?: number;
}
/**
 *
 * \brief The dimension of a 3D box, e.g. the size of a 3D bounding box or its
 * uncertainties.
 *
 * \image html OSI_Dimension3D.svg
 *
 * The dimensions are positive. Uncertainties are negative or positive.
 *
 * Dimension is defined in the specified reference coordinate frame along the
 * x-axis (=length), y-axis (=width) and z-axis (=height).
 *
 *
 * @generated from protobuf message osi3.Dimension3d
 */
export interface Dimension3d {
    /**
     * The length of the box.
     *
     * Unit: m
     *
     * \rules
     * is_greater_than_or_equal_to: 0
     * \endrules
     *
     *
     * @generated from protobuf field: optional double length = 1;
     */
    length?: number;
    /**
     * The width of the box.
     *
     * Unit: m
     *
     * \rules
     * is_greater_than_or_equal_to: 0
     * \endrules
     *
     *
     * @generated from protobuf field: optional double width = 2;
     */
    width?: number;
    /**
     * The height of the box.
     *
     * Unit: m
     *
     * \rules
     * is_greater_than_or_equal_to: 0
     * \endrules
     *
     *
     * @generated from protobuf field: optional double height = 3;
     */
    height?: number;
}
/**
 *
 * \brief A 3D orientation, orientation rate or orientation acceleration (i.e.
 * derivatives) or its uncertainties denoted in euler angles.
 *
 * Units are rad for orientation, rad/s for rates, and rad/s^2 for
 * accelerations
 *
 * The coordinate system is defined as right-handed.
 * For the sense of each rotation, the right-hand rule applies.
 *
 * The rotations are to be performed \b yaw \b first (around the z-axis),
 * \b pitch \b second (around the new y-axis) and \b roll \b third (around the
 * new x-axis) to follow the definition according to [1] (Tait-Bryan / Euler
 * convention z-y'-x''). The preferred angular range is [-pi, pi] for roll
 * and yaw and [-pi/2, pi/2] for pitch.
 *
 * Roll/Pitch are 0 if the objects xy-plane is parallel to its parent's
 * xy-plane. Yaw is 0 if the object's local x-axis is parallel to its parent's
 * x-axis.
 *
 * \f$ Rotation_{yaw,pitch,roll} =
 * Rotation_{yaw}*Rotation_{pitch}*Rotation_{roll} \f$
 *
 * \f$ vector_{gobal coord system} := Rotation_{yaw, pitch, roll} * vector_{local coord system} +local_{origin::position} \f$
 *
 * \attention This definition changed in OSI version 3.0.0. Previous OSI
 * versions  (V2.xx) had an other definition.
 *
 * \par Reference:
 * [1] DIN Deutsches Institut fuer Normung e. V. (2013). <em>DIN ISO 8855 Strassenfahrzeuge - Fahrzeugdynamik und Fahrverhalten - Begriffe</em>. (DIN ISO 8855:2013-11). Berlin, Germany.
 *
 *
 * @generated from protobuf message osi3.Orientation3d
 */
export interface Orientation3d {
    /**
     * The roll angle/rate/acceleration.
     *
     * Unit: rad, rad/s, or rad/s^2
     *
     *
     * @generated from protobuf field: optional double roll = 1;
     */
    roll?: number;
    /**
     * The pitch angle/rate/acceleration.
     *
     * Unit: rad, rad/s, or rad/s^2
     *
     *
     * @generated from protobuf field: optional double pitch = 2;
     */
    pitch?: number;
    /**
     * The yaw angle/rate/acceleration.
     *
     * Unit: rad, rad/s, or rad/s^2
     *
     *
     * @generated from protobuf field: optional double yaw = 3;
     */
    yaw?: number;
}
/**
 *
 * \brief A common identifier (ID), represented as an integer.
 *
 * Has to be unique among all simulated items at any given time. For ground
 * truth, the identifier of an item (object, lane, sign, etc.) must remain
 * stable over its lifetime. \c Identifier values may be only be reused if the
 * available address space is exhausted and the specific values have not been in
 * use for several timesteps. Sensor specific tracking IDs have no restrictions
 * and should behave according to the sensor specifications.
 *
 * The value MAX(uint64) = 2^(64) -1 =
 * 0b1111111111111111111111111111111111111111111111111111111111111111 is
 * reserved and indicates an invalid ID or error.
 *
 *
 * @generated from protobuf message osi3.Identifier
 */
export interface Identifier {
    /**
     * The identifier's value.
     *
     * \rules
     * is_greater_than_or_equal_to: 0
     * \endrules
     *
     *
     * @generated from protobuf field: optional uint64 value = 1;
     */
    value?: bigint;
}
/**
 * \brief References to external objects.
 *
 * The external reference is an optional recommendation to refer to objects defined outside of OSI.
 * This could be other OpenX standards, 3rd-party standards or user-defined objects.
 *
 * \note ExternalReference is optional and can be left empty.
 *
 *
 * @generated from protobuf message osi3.ExternalReference
 */
export interface ExternalReference {
    /**
     * The source of the external references.
     *
     * Defines the original source of an object as uniquely identifiable reference.
     * In case of using \c GroundTruth::map_reference or
     * \c GroundTruth::model_reference, the reference can be left empty.
     * If not otherwise required, an URI is suggested. The syntax should follow
     * \link https://tools.ietf.org/html/rfc3986 RFC 3986\endlink.
     *
     *
     *
     * @generated from protobuf field: optional string reference = 1;
     */
    reference?: string;
    /**
     * The type of the external references.
     *
     * Mandatory value describing the type of the original source.
     *
     * For OpenX/ASAM standards it is specified as follows:
     * - net.asam.opendrive
     * - net.asam.openscenario
     *
     * For third-party standards and user-defined objects,
     * reverse domain name notation with lower-case type field
     * is recommended to guarantee unique and interoperable identification.
     *
     *
     * @generated from protobuf field: optional string type = 2;
     */
    type?: string;
    /**
     * The external identifier reference value.
     *
     * The repeated string is chosen as a common description of the external
     * identifier, because a variety of identificatier types could be
     * involved .
     *
     * For example, referencing a unique lane in OpenDRIVE requires the
     * following identifiers:
     * * RoadId: String
     * * S-Value of LaneSection: Double
     * * LaneId: Int
     *
     * \note The detailed description of the identifiers and how they are
     *       used for referencing external objects is given in the individual
     *       messages where the external identifier is used.
     *
     * \see EnvironmentalConditions::source_reference
     * \see Lane::source_reference
     * \see LaneBoundary::source_reference
     * \see StationaryObject::source_reference
     * \see MovingObject::source_reference
     * \see RoadMarking::source_reference
     * \see TrafficLight::source_reference
     * \see TrafficSign::source_reference
     *
     *
     * @generated from protobuf field: repeated string identifier = 3;
     */
    identifier: string[];
}
/**
 *
 * \brief Specifies the mounting position of a sensor.
 *
 * Details are specified in each instance where \c MountingPosition is used.
 *
 *
 * @generated from protobuf message osi3.MountingPosition
 */
export interface MountingPosition {
    /**
     * Offset position relative to the specified reference coordinate system.
     *
     *
     * @generated from protobuf field: optional osi3.Vector3d position = 1;
     */
    position?: Vector3d;
    /**
     * Orientation offset relative to the specified reference coordinate system.
     *
     * \f$ Origin_{sensor} :=
     * Rotation_{yaw,pitch,roll}( \f$ \c #orientation \f$
     * )*(Origin_{\text{reference coord system}}
     * - \f$ \c #position \f$ )\f$
     *
     *
     * @generated from protobuf field: optional osi3.Orientation3d orientation = 2;
     */
    orientation?: Orientation3d;
}
/**
 *
 * \brief A spherical representation for a point or vector in 3D space.
 *
 * Used e.g., for low level representations of radar detections.
 *
 * Azimuth and elevation are defined as the rotations that would have to be
 * applied to the local frame (e.g sensor frame definition in
 * \c SensorDetectionHeader) to make its x-axis point towards the referenced
 * point or to align it with the referenced vector. The rotations are to be
 * performed \b azimuth \b first (around the z-axis) and \b elevation \b second
 * (around the new y-axis) to follow the definition of \c Orientation3d. For the
 * sense of each rotation, the right-hand rule applies.
 *
 * \f$ vector_{cartesian} :=
 * Rotation( \f$ \c #elevation \f$ )*Rotation( \f$ \c #azimuth \f$ )*
 * (Unit_{vector_x}* \f$ \c #distance \f$ ) \f$
 *
 *
 * @generated from protobuf message osi3.Spherical3d
 */
export interface Spherical3d {
    /**
     * The radial distance.
     *
     * Unit: m
     *
     * \rules
     * is_greater_than_or_equal_to: 0
     * \endrules
     *
     *
     * @generated from protobuf field: optional double distance = 1;
     */
    distance?: number;
    /**
     * The azimuth (horizontal) angle.
     *
     * Unit: rad
     *
     *
     * @generated from protobuf field: optional double azimuth = 2;
     */
    azimuth?: number;
    /**
     * The elevation (vertical) angle.
     *
     * Unit: rad
     *
     *
     * @generated from protobuf field: optional double elevation = 3;
     */
    elevation?: number;
}
/**
 *
 * \brief The base attributes of a stationary object or entity.
 *
 * This includes the \c StationaryObject , \c TrafficSign ,
 * \c TrafficLight , \c RoadMarking messages.
 *
 * \image html OSI_BaseStationary.svg
 *
 * All coordinates and orientations from ground truth objects are relative to
 * the global ground truth frame (see image). (All coordinates and orientations
 * from detected objects are relative to the host vehicle frame (see:
 * \c Vehicle vehicle reference point).)
 *
 *
 * @generated from protobuf message osi3.BaseStationary
 */
export interface BaseStationary {
    /**
     * The 3D dimensions of the stationary object (bounding box), e.g. a
     * landmark.
     *
     *
     * @generated from protobuf field: optional osi3.Dimension3d dimension = 1;
     */
    dimension?: Dimension3d;
    /**
     * The reference point for position and orientation, i.e. the center (x,y,z)
     * of the bounding box.
     *
     *
     * @generated from protobuf field: optional osi3.Vector3d position = 2;
     */
    position?: Vector3d;
    /**
     * The relative orientation of the stationary object w.r.t. its parent
     * frame, noted in the parent frame. The orientation becomes global/absolute
     * if the parent frame is inertial (all parent frames up to ground truth).
     *
     * \f$ Origin_{\text{base stationary entity}} :=
     * Rotation_{yaw,pitch,roll}( \f$ \c #orientation \f$ )*
     * (Origin_{\text{parent coord system}} -
     * \f$ \c #position \f$ )\f$
     *
     * \note There may be some constraints how to align the orientation w.r.t.
     * to some stationary object's or entity's definition.
     *
     *
     * @generated from protobuf field: optional osi3.Orientation3d orientation = 3;
     */
    orientation?: Orientation3d;
    /**
     * Usage as ground truth:
     * The two dimensional (flat) contour of the object. This is an extension of
     * the concept of a bounding box as defined by \c Dimension3d. The contour
     * is the projection of the object's outline onto the z-plane in the object
     * frame (independent of its current position and orientation). The height
     * is the same as the height of the bounding box.
     *
     * Usage as sensor data:
     * The polygon describes the visible part of the object's contour.
     *
     * General definitions:
     * The polygon is defined in the local object frame: x pointing forward and
     * y to the left.
     * The origin is the center of the bounding box.
     * As ground truth, the polygon is closed by connecting the last with the
     * first point. Therefore these two points must be different. The polygon
     * must consist of at least three points.
     * As sensor data, however, the polygon is open.
     * The polygon is defined counter-clockwise.
     *
     *
     * @generated from protobuf field: repeated osi3.Vector2d base_polygon = 4;
     */
    basePolygon: Vector2d[];
}
/**
 *
 * \brief The base attributes of an object that is moving.
 *
 * This includes the \c MovingObject messages.
 *
 * \image html OSI_BaseMoving.svg
 *
 * \image html OSI_BaseMoving_Top.svg
 *
 * E.g. a vehicle is a base moving object.
 *
 * All coordinates and orientations from ground truth objects are relative to
 * the global ground truth frame. All coordinates and orientations
 * from detected objects are relative to the host vehicle frame
 * (see: \c MovingObject vehicle reference point).
 *
 *
 * @generated from protobuf message osi3.BaseMoving
 */
export interface BaseMoving {
    /**
     * The 3D dimension of the moving object (its bounding box).
     *
     * \note The bounding box does NOT include side mirrors for vehicles.
     *
     *
     * @generated from protobuf field: optional osi3.Dimension3d dimension = 1;
     */
    dimension?: Dimension3d;
    /**
     * The reference point for position and orientation: the center (x,y,z) of
     * the bounding box.
     *
     *
     * @generated from protobuf field: optional osi3.Vector3d position = 2;
     */
    position?: Vector3d;
    /**
     * The relative orientation of the moving object w.r.t. its parent frame,
     * noted in the parent frame. The orientation becomes global/absolute if
     * the parent frame is inertial (all parent frames up to ground truth).
     *
     * \f$ Origin_{\text{base moving entity}} :=
     * Rotation_{yaw,pitch,roll}( \f$ \c #orientation \f$ )*
     * (Origin_{\text{parent coord system}} -
     * \f$ \c #position \f$ ) \f$
     *
     * \note There may be some constraints how to align the orientation w.r.t.
     * to some stationary object's or entity's definition.
     *
     *
     * @generated from protobuf field: optional osi3.Orientation3d orientation = 3;
     */
    orientation?: Orientation3d;
    /**
     * The relative velocity of the moving object w.r.t. the parent frame,
     * noted in the parent frame. The velocity becomes global/absolute if
     * the parent frame does is inertial (all parent frames up to ground truth).
     *
     * \c #position \f$ (t) := \f$ \c #position \f$ (t-dt)+ \f$ \c #velocity \f$
     * *dt \f$
     *
     *
     * @generated from protobuf field: optional osi3.Vector3d velocity = 4;
     */
    velocity?: Vector3d;
    /**
     * The relative acceleration of the moving object w.r.t. its parent frame,
     * noted in the parent frame. The acceleration becomes global/absolute if
     * the parent frame is inertial (all parent frames up to ground truth).
     *
     * \c #position \f$ (t) := \f$ \c #position \f$ (t-dt)+ \f$ \c #velocity \f$
     * *dt+ \f$ \c #acceleration \f$ /2*dt^2\f$
     *
     * \c #velocity \f$ (t) := \f$ \c #velocity \f$ (t-dt)+ \f$ \c #acceleration
     * \f$ *dt \f$
     *
     *
     * @generated from protobuf field: optional osi3.Vector3d acceleration = 5;
     */
    acceleration?: Vector3d;
    /**
     * The relative orientation rate of the moving object w.r.t. its parent
     * frame and parent orientation rate in the center point of the bounding box
     * (origin of the bounding box frame), noted in the parent frame.
     * The orientation becomes global/absolute if the parent frame is inertial
     * (all parent frames up to ground truth).
     *
     * \c #orientation \f$ .yaw(t) := \f$ \c #orientation_rate \f$ .yaw(t) * dt
     * + \f$ \c #orientation \f$ .yaw(t-dt) \f$
     *
     * \c #orientation \f$ .pitch(t) := \f$ \c #orientation_rate \f$ .pitch(t) *
     * dt + \f$ \c #orientation \f$ .pitch(t-dt) \f$
     *
     * \c #orientation \f$ .roll(t) := \f$ \c #orientation_rate \f$ .roll(t) *
     * dt + \f$ \c #orientation \f$ .roll(t-dt)\f$
     *
     *
     * @generated from protobuf field: optional osi3.Orientation3d orientation_rate = 6;
     */
    orientationRate?: Orientation3d;
    /**
     * The relative orientation acceleration of the moving object w.r.t. its
     * parent frame and parent orientation acceleration in the center point of
     * the bounding box (origin of the bounding box frame), noted in the parent
     * frame. The orientation becomes global/absolute if the parent frame is
     * inertial (all parent frames up to ground truth).
     *
     * \c #orientation_rate \f$ .yaw(t) := \f$ \c #orientation_acceleration \f$
     * .yaw(t) * dt + \f$ \c #orientation_rate \f$ .yaw(t-dt) \f$
     *
     * \c #orientation_rate \f$ .pitch(t) := \f$ \c #orientation_acceleration
     * \f$ .pitch(t) * dt
     * + \f$ \c #orientation_rate \f$ .pitch(t-dt) \f$
     *
     * \c #orientation_rate \f$ .roll(t) := \f$ \c #orientation_acceleration \f$
     * .roll(t) * dt +
     *  \f$ \c #orientation_rate \f$ .roll(t-dt) \f$
     *
     *
     * @generated from protobuf field: optional osi3.Orientation3d orientation_acceleration = 8;
     */
    orientationAcceleration?: Orientation3d;
    /**
     * Usage as ground truth:
     * The two dimensional (flat) contour of the object. This is an extension of
     * the concept of a bounding box as defined by \c Dimension3d. The contour
     * is the projection of the object's outline onto the z-plane in the object
     * frame (independent of its current position and orientation). The height
     * is the same as the height of the bounding box.
     *
     * Usage as sensor data:
     * The polygon describes the visible part of the object's contour.
     *
     * General definitions:
     * The polygon is defined in the local object frame: x pointing forward and
     * y to the left. The origin is the center of the bounding box.
     * As ground truth, the polygon is closed by connecting the last with the
     * first point. Therefore these two points must be different. The polygon
     * must consist of at least three points. As sensor data, however, the
     * polygon is open.
     * The polygon is defined counter-clockwise.
     *
     *
     * @generated from protobuf field: repeated osi3.Vector2d base_polygon = 7;
     */
    basePolygon: Vector2d[];
}
/**
 *
 * \brief The StatePoint definition
 *
 * A reference to a time and pose.  Typically used in a repeated field to define
 * a trajectory.
 *
 * \note The StatePoint definition does not define mandatory fields.
 * The context defines how and what fields are used.  For example, in some cases
 * only the pose variables are relevant and the timestamp is ignored.
 *
 *
 * @generated from protobuf message osi3.StatePoint
 */
export interface StatePoint {
    /**
     * The timestamp of a StatePoint.
     *
     * \note Zero time does not need to coincide with the UNIX epoch.
     *
     *
     * @generated from protobuf field: optional osi3.Timestamp timestamp = 1;
     */
    timestamp?: Timestamp;
    /**
     * Position in the global coordinate system.
     *
     * \note Remark: The definition of the reference point follows the
     * specification of the \c BaseMoving message.
     *
     *
     * @generated from protobuf field: optional osi3.Vector3d position = 2;
     */
    position?: Vector3d;
    /**
     * Orientation in the global coordinate system.
     *
     *
     * @generated from protobuf field: optional osi3.Orientation3d orientation = 3;
     */
    orientation?: Orientation3d;
}
/**
 *
 * \brief Detailed WavelengthRange message.
 *
 * Defines the start (minimum) and the end (maximum) values of the wavelength.
 * Additionally, the number of samples within this range is defined in this message.
 *
 *
 * @generated from protobuf message osi3.WavelengthData
 */
export interface WavelengthData {
    /**
     * The start, or the minimum wavelength value.
     *
     * Unit: m
     *
     *
     * @generated from protobuf field: optional double start = 1;
     */
    start?: number;
    /**
     * The end, or the maximum wavelength value.
     *
     * Unit: m
     *
     *
     * @generated from protobuf field: optional double end = 2;
     */
    end?: number;
    /**
     * Number of samples to be considered within the defined wavelength range.
     * The number of samples includes the start and the end values that are defined in this message, starting from the "start" value.
     * \note This defines the number of wavelengths to be computed during simulation, not to be confused with samples_per_pixel.
     *
     *
     * @generated from protobuf field: optional double samples_number = 3;
     */
    samplesNumber?: number;
}
/**
 *
 * \brief Definition of a spatial signal strength distribution
 * for an emitting / transmitting / receiving entity
 * with a horizontal and a vertical angle
 * and the corresponding signal strength in dBm (decibels per milliwatt).
 *
 *
 * @generated from protobuf message osi3.SpatialSignalStrength
 */
export interface SpatialSignalStrength {
    /**
     * Horizontal angle (azimuth) of emission / transmission / reception
     * in the entity's coordinate system.
     *
     * Unit: rad
     *
     *
     * @generated from protobuf field: optional double horizontal_angle = 1;
     */
    horizontalAngle?: number;
    /**
     * Vertical angle (elevation) of emission / transmission / reception
     * in the entity's coordinate system.
     *
     * Unit: rad
     *
     *
     * @generated from protobuf field: optional double vertical_angle = 2;
     */
    verticalAngle?: number;
    /**
     * Emitted / transmitted /received signal strength
     * of the emitting / transmitting / receiving entity
     * at the previously defined horizontal and
     * vertical angle for one specific wavelength.
     * The value for the signal strength
     * is given in dBm (decibels per milliwatt).
     *
     * Unit: dBm
     *
     *
     * @generated from protobuf field: optional double signal_strength = 3;
     */
    signalStrength?: number;
}
/**
 *
 * \brief The description of a color within available color spaces.
 *
 * ColorDescription represents the visual, non-semantic appearance of an object, structure or feature within various available color spaces.
 *
 * Depending on the context, this may define the color of an object or structure a priori (e.g. GroundTruth objects)
 * or describe a perceived color (e.g. CameraDetections).
 *
 *
 * @generated from protobuf message osi3.ColorDescription
 */
export interface ColorDescription {
    /**
     * Greyscale color model
     *
     *
     * @generated from protobuf field: optional osi3.ColorGrey grey = 1;
     */
    grey?: ColorGrey;
    /**
     * RGB (Red, Green, Blue) color model
     *
     *
     * @generated from protobuf field: optional osi3.ColorRGB rgb = 2;
     */
    rgb?: ColorRGB;
    /**
     * RGBIR (Red, Green, Blue, Infrared) color model
     *
     *
     * @generated from protobuf field: optional osi3.ColorRGBIR rgbir = 3;
     */
    rgbir?: ColorRGBIR;
    /**
     * HSV (Hue, Saturation, Value) color model
     *
     *
     * @generated from protobuf field: optional osi3.ColorHSV hsv = 4;
     */
    hsv?: ColorHSV;
    /**
     * LUV (Luminance, U-coordinate, V-coordinate) color model
     *
     *
     * @generated from protobuf field: optional osi3.ColorLUV luv = 5;
     */
    luv?: ColorLUV;
    /**
     * CMYK (Cyan, Magenta, Yellow, Key) color model
     *
     *
     * @generated from protobuf field: optional osi3.ColorCMYK cmyk = 6;
     */
    cmyk?: ColorCMYK;
}
/**
 *
 * \brief Greyscale color model
 *
 * ColorGrey defines a greyscale.
 *
 *
 * @generated from protobuf message osi3.ColorGrey
 */
export interface ColorGrey {
    /**
     * Definition of a greyscale
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double grey = 1;
     */
    grey?: number;
}
/**
 *
 * \brief RGB color model
 *
 * ColorRGB provides values for red, green and blue.
 *
 *
 * @generated from protobuf message osi3.ColorRGB
 */
export interface ColorRGB {
    /**
     * Red ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double red = 1;
     */
    red?: number;
    /**
     * Green ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double green = 2;
     */
    green?: number;
    /**
     * Blue ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double blue = 3;
     */
    blue?: number;
}
/**
 *
 * \brief RGBIR color model
 *
 * ColorRGBIR provides values for red, green, blue and infrared.
 *
 *
 * @generated from protobuf message osi3.ColorRGBIR
 */
export interface ColorRGBIR {
    /**
     * Red ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double red = 1;
     */
    red?: number;
    /**
     * Green ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double green = 2;
     */
    green?: number;
    /**
     * Blue ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double blue = 3;
     */
    blue?: number;
    /**
     * Infrared
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double infrared = 4;
     */
    infrared?: number;
}
/**
 *
 * \brief HSV color model
 *
 * ColorHSV provides values for hue, saturation and value/brightness.
 *
 *
 * @generated from protobuf message osi3.ColorHSV
 */
export interface ColorHSV {
    /**
     * Hue
     *
     * Unit: deg
     * Range: [0,360[
     *
     *
     * @generated from protobuf field: optional double hue = 1;
     */
    hue?: number;
    /**
     * Saturation
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double saturation = 2;
     */
    saturation?: number;
    /**
     * Value
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double value = 3;
     */
    value?: number;
}
/**
 *
 * \brief LUV color model
 *
 * ColorLUV provides values for luminance, U- and V-coordinate.
 *
 *
 * @generated from protobuf message osi3.ColorLUV
 */
export interface ColorLUV {
    /**
     * Luminance
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double luminance = 1;
     */
    luminance?: number;
    /**
     * U-coordinate
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double u = 2;
     */
    u?: number;
    /**
     * V-Coordinate
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double v = 3;
     */
    v?: number;
}
/**
 *
 * \brief CMYK colors model
 *
 * ColorCMYK provides values for cyan, magenta, yellow and key/black.
 *
 *
 * @generated from protobuf message osi3.ColorCMYK
 */
export interface ColorCMYK {
    /**
     * Cyan ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double cyan = 1;
     */
    cyan?: number;
    /**
     * Magenta ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double magenta = 2;
     */
    magenta?: number;
    /**
     * Yellow ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double yellow = 3;
     */
    yellow?: number;
    /**
     * Black ratio
     *
     * Range: [0,1]
     *
     *
     * @generated from protobuf field: optional double key = 4;
     */
    key?: number;
}
/**
 *
 * \brief A description for the positions of the pedals.
 *
 *
 * @generated from protobuf message osi3.Pedalry
 */
export interface Pedalry {
    /**
     * Position of the acceleration pedal.
     * Range: 0-1 (Unpressed - fully pressed)
     *
     *
     * @generated from protobuf field: optional double pedal_position_acceleration = 1;
     */
    pedalPositionAcceleration?: number;
    /**
     * Position of the brake pedal.
     * Range: 0-1 (Unpressed - fully pressed)
     *
     *
     * @generated from protobuf field: optional double pedal_position_brake = 2;
     */
    pedalPositionBrake?: number;
    /**
     * Position of the clutch pedal.
     * Range: 0-1 (Unpressed - fully pressed)
     *
     *
     * @generated from protobuf field: optional double pedal_position_clutch = 3;
     */
    pedalPositionClutch?: number;
}
/**
 *
 * \brief A description of the steering wheel.
 *
 *
 * @generated from protobuf message osi3.VehicleSteeringWheel
 */
export interface VehicleSteeringWheel {
    /**
     * Angle of the steering wheel.
     * Zero means the steering wheel is in its center position. A positive value
     * means the steering wheel is turned to the left. A negative value
     * means the steering wheel is turned to the right of the center position.
     *
     * Unit: rad
     *
     *
     * @generated from protobuf field: optional double angle = 1;
     */
    angle?: number;
    /**
     * Angular speed of the steering wheel.
     * Zero means the steering wheel stays in its position. A positive value
     * means the steering wheel is turned to the left. A negative value
     * means the steering wheel is turned to the right.
     *
     * Unit: rad/s
     *
     *
     * @generated from protobuf field: optional double angular_speed = 2;
     */
    angularSpeed?: number;
    /**
     * Torque of the steering wheel to the hand.
     * Zero means there is no force from the steering wheel to the hand of the driver.
     * A positive value means that the steering wheel would turn to the left without driver intervention.
     * A negative value means that the steering wheel would turn to the right without driver intervention.
     *
     * Unit: N*m
     *
     *
     * @generated from protobuf field: optional double torque = 3;
     */
    torque?: number;
}
/**
 *
 * \brief The geodetic position of an object, that is, the center of the 3D bounding box.
 *
 *
 * @generated from protobuf message osi3.GeodeticPosition
 */
export interface GeodeticPosition {
    /**
     * Longitude in decimal degrees regarding WGS84.
     *
     * Unit: Degree
     * Range: [-180; 180]
     *
     *
     * @generated from protobuf field: optional double longitude = 1;
     */
    longitude?: number;
    /**
     * Latitude in decimal degrees regarding WGS84.
     *
     * Unit: Degree
     * Range: [-90; 90]
     *
     *
     * @generated from protobuf field: optional double latitude = 2;
     */
    latitude?: number;
    /**
     * Height above sea level regarding EGM96.
     *
     * Unit: m
     * Range: [-300; 10000]
     *
     *
     * @generated from protobuf field: optional double altitude = 3;
     */
    altitude?: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class Vector3d$Type extends MessageType<Vector3d> {
    constructor() {
        super("osi3.Vector3d", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "z", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Vector3d>): Vector3d {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Vector3d>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector3d): Vector3d {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double x */ 1:
                    message.x = reader.double();
                    break;
                case /* optional double y */ 2:
                    message.y = reader.double();
                    break;
                case /* optional double z */ 3:
                    message.z = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector3d, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* optional double y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit64).double(message.y);
        /* optional double z = 3; */
        if (message.z !== undefined)
            writer.tag(3, WireType.Bit64).double(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.Vector3d
 */
export const Vector3d = new Vector3d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector2d$Type extends MessageType<Vector2d> {
    constructor() {
        super("osi3.Vector2d", [
            { no: 1, name: "x", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Vector2d>): Vector2d {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Vector2d>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector2d): Vector2d {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double x */ 1:
                    message.x = reader.double();
                    break;
                case /* optional double y */ 2:
                    message.y = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector2d, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double x = 1; */
        if (message.x !== undefined)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* optional double y = 2; */
        if (message.y !== undefined)
            writer.tag(2, WireType.Bit64).double(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.Vector2d
 */
export const Vector2d = new Vector2d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Timestamp$Type extends MessageType<Timestamp> {
    constructor() {
        super("osi3.Timestamp", [
            { no: 1, name: "seconds", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "nanos", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Timestamp>): Timestamp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Timestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Timestamp): Timestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 seconds */ 1:
                    message.seconds = reader.int64().toBigInt();
                    break;
                case /* optional uint32 nanos */ 2:
                    message.nanos = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Timestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 seconds = 1; */
        if (message.seconds !== undefined)
            writer.tag(1, WireType.Varint).int64(message.seconds);
        /* optional uint32 nanos = 2; */
        if (message.nanos !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.nanos);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.Timestamp
 */
export const Timestamp = new Timestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Dimension3d$Type extends MessageType<Dimension3d> {
    constructor() {
        super("osi3.Dimension3d", [
            { no: 1, name: "length", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "width", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Dimension3d>): Dimension3d {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Dimension3d>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Dimension3d): Dimension3d {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double length */ 1:
                    message.length = reader.double();
                    break;
                case /* optional double width */ 2:
                    message.width = reader.double();
                    break;
                case /* optional double height */ 3:
                    message.height = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Dimension3d, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double length = 1; */
        if (message.length !== undefined)
            writer.tag(1, WireType.Bit64).double(message.length);
        /* optional double width = 2; */
        if (message.width !== undefined)
            writer.tag(2, WireType.Bit64).double(message.width);
        /* optional double height = 3; */
        if (message.height !== undefined)
            writer.tag(3, WireType.Bit64).double(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.Dimension3d
 */
export const Dimension3d = new Dimension3d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Orientation3d$Type extends MessageType<Orientation3d> {
    constructor() {
        super("osi3.Orientation3d", [
            { no: 1, name: "roll", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "pitch", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "yaw", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Orientation3d>): Orientation3d {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Orientation3d>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Orientation3d): Orientation3d {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double roll */ 1:
                    message.roll = reader.double();
                    break;
                case /* optional double pitch */ 2:
                    message.pitch = reader.double();
                    break;
                case /* optional double yaw */ 3:
                    message.yaw = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Orientation3d, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double roll = 1; */
        if (message.roll !== undefined)
            writer.tag(1, WireType.Bit64).double(message.roll);
        /* optional double pitch = 2; */
        if (message.pitch !== undefined)
            writer.tag(2, WireType.Bit64).double(message.pitch);
        /* optional double yaw = 3; */
        if (message.yaw !== undefined)
            writer.tag(3, WireType.Bit64).double(message.yaw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.Orientation3d
 */
export const Orientation3d = new Orientation3d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Identifier$Type extends MessageType<Identifier> {
    constructor() {
        super("osi3.Identifier", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Identifier>): Identifier {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Identifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Identifier): Identifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 value */ 1:
                    message.value = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Identifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 value = 1; */
        if (message.value !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.Identifier
 */
export const Identifier = new Identifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalReference$Type extends MessageType<ExternalReference> {
    constructor() {
        super("osi3.ExternalReference", [
            { no: 1, name: "reference", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "identifier", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExternalReference>): ExternalReference {
        const message = { identifier: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExternalReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalReference): ExternalReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string reference */ 1:
                    message.reference = reader.string();
                    break;
                case /* optional string type */ 2:
                    message.type = reader.string();
                    break;
                case /* repeated string identifier */ 3:
                    message.identifier.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string reference = 1; */
        if (message.reference !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.reference);
        /* optional string type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* repeated string identifier = 3; */
        for (let i = 0; i < message.identifier.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.identifier[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.ExternalReference
 */
export const ExternalReference = new ExternalReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountingPosition$Type extends MessageType<MountingPosition> {
    constructor() {
        super("osi3.MountingPosition", [
            { no: 1, name: "position", kind: "message", T: () => Vector3d },
            { no: 2, name: "orientation", kind: "message", T: () => Orientation3d }
        ]);
    }
    create(value?: PartialMessage<MountingPosition>): MountingPosition {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MountingPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountingPosition): MountingPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional osi3.Vector3d position */ 1:
                    message.position = Vector3d.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional osi3.Orientation3d orientation */ 2:
                    message.orientation = Orientation3d.internalBinaryRead(reader, reader.uint32(), options, message.orientation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountingPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional osi3.Vector3d position = 1; */
        if (message.position)
            Vector3d.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Orientation3d orientation = 2; */
        if (message.orientation)
            Orientation3d.internalBinaryWrite(message.orientation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.MountingPosition
 */
export const MountingPosition = new MountingPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Spherical3d$Type extends MessageType<Spherical3d> {
    constructor() {
        super("osi3.Spherical3d", [
            { no: 1, name: "distance", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "azimuth", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "elevation", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Spherical3d>): Spherical3d {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Spherical3d>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Spherical3d): Spherical3d {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double distance */ 1:
                    message.distance = reader.double();
                    break;
                case /* optional double azimuth */ 2:
                    message.azimuth = reader.double();
                    break;
                case /* optional double elevation */ 3:
                    message.elevation = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Spherical3d, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double distance = 1; */
        if (message.distance !== undefined)
            writer.tag(1, WireType.Bit64).double(message.distance);
        /* optional double azimuth = 2; */
        if (message.azimuth !== undefined)
            writer.tag(2, WireType.Bit64).double(message.azimuth);
        /* optional double elevation = 3; */
        if (message.elevation !== undefined)
            writer.tag(3, WireType.Bit64).double(message.elevation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.Spherical3d
 */
export const Spherical3d = new Spherical3d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BaseStationary$Type extends MessageType<BaseStationary> {
    constructor() {
        super("osi3.BaseStationary", [
            { no: 1, name: "dimension", kind: "message", T: () => Dimension3d },
            { no: 2, name: "position", kind: "message", T: () => Vector3d },
            { no: 3, name: "orientation", kind: "message", T: () => Orientation3d },
            { no: 4, name: "base_polygon", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Vector2d }
        ]);
    }
    create(value?: PartialMessage<BaseStationary>): BaseStationary {
        const message = { basePolygon: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BaseStationary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BaseStationary): BaseStationary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional osi3.Dimension3d dimension */ 1:
                    message.dimension = Dimension3d.internalBinaryRead(reader, reader.uint32(), options, message.dimension);
                    break;
                case /* optional osi3.Vector3d position */ 2:
                    message.position = Vector3d.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional osi3.Orientation3d orientation */ 3:
                    message.orientation = Orientation3d.internalBinaryRead(reader, reader.uint32(), options, message.orientation);
                    break;
                case /* repeated osi3.Vector2d base_polygon */ 4:
                    message.basePolygon.push(Vector2d.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BaseStationary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional osi3.Dimension3d dimension = 1; */
        if (message.dimension)
            Dimension3d.internalBinaryWrite(message.dimension, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Vector3d position = 2; */
        if (message.position)
            Vector3d.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Orientation3d orientation = 3; */
        if (message.orientation)
            Orientation3d.internalBinaryWrite(message.orientation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated osi3.Vector2d base_polygon = 4; */
        for (let i = 0; i < message.basePolygon.length; i++)
            Vector2d.internalBinaryWrite(message.basePolygon[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.BaseStationary
 */
export const BaseStationary = new BaseStationary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BaseMoving$Type extends MessageType<BaseMoving> {
    constructor() {
        super("osi3.BaseMoving", [
            { no: 1, name: "dimension", kind: "message", T: () => Dimension3d },
            { no: 2, name: "position", kind: "message", T: () => Vector3d },
            { no: 3, name: "orientation", kind: "message", T: () => Orientation3d },
            { no: 4, name: "velocity", kind: "message", T: () => Vector3d },
            { no: 5, name: "acceleration", kind: "message", T: () => Vector3d },
            { no: 6, name: "orientation_rate", kind: "message", T: () => Orientation3d },
            { no: 8, name: "orientation_acceleration", kind: "message", T: () => Orientation3d },
            { no: 7, name: "base_polygon", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Vector2d }
        ]);
    }
    create(value?: PartialMessage<BaseMoving>): BaseMoving {
        const message = { basePolygon: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BaseMoving>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BaseMoving): BaseMoving {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional osi3.Dimension3d dimension */ 1:
                    message.dimension = Dimension3d.internalBinaryRead(reader, reader.uint32(), options, message.dimension);
                    break;
                case /* optional osi3.Vector3d position */ 2:
                    message.position = Vector3d.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional osi3.Orientation3d orientation */ 3:
                    message.orientation = Orientation3d.internalBinaryRead(reader, reader.uint32(), options, message.orientation);
                    break;
                case /* optional osi3.Vector3d velocity */ 4:
                    message.velocity = Vector3d.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* optional osi3.Vector3d acceleration */ 5:
                    message.acceleration = Vector3d.internalBinaryRead(reader, reader.uint32(), options, message.acceleration);
                    break;
                case /* optional osi3.Orientation3d orientation_rate */ 6:
                    message.orientationRate = Orientation3d.internalBinaryRead(reader, reader.uint32(), options, message.orientationRate);
                    break;
                case /* optional osi3.Orientation3d orientation_acceleration */ 8:
                    message.orientationAcceleration = Orientation3d.internalBinaryRead(reader, reader.uint32(), options, message.orientationAcceleration);
                    break;
                case /* repeated osi3.Vector2d base_polygon */ 7:
                    message.basePolygon.push(Vector2d.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BaseMoving, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional osi3.Dimension3d dimension = 1; */
        if (message.dimension)
            Dimension3d.internalBinaryWrite(message.dimension, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Vector3d position = 2; */
        if (message.position)
            Vector3d.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Orientation3d orientation = 3; */
        if (message.orientation)
            Orientation3d.internalBinaryWrite(message.orientation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Vector3d velocity = 4; */
        if (message.velocity)
            Vector3d.internalBinaryWrite(message.velocity, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Vector3d acceleration = 5; */
        if (message.acceleration)
            Vector3d.internalBinaryWrite(message.acceleration, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Orientation3d orientation_rate = 6; */
        if (message.orientationRate)
            Orientation3d.internalBinaryWrite(message.orientationRate, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Orientation3d orientation_acceleration = 8; */
        if (message.orientationAcceleration)
            Orientation3d.internalBinaryWrite(message.orientationAcceleration, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated osi3.Vector2d base_polygon = 7; */
        for (let i = 0; i < message.basePolygon.length; i++)
            Vector2d.internalBinaryWrite(message.basePolygon[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.BaseMoving
 */
export const BaseMoving = new BaseMoving$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatePoint$Type extends MessageType<StatePoint> {
    constructor() {
        super("osi3.StatePoint", [
            { no: 1, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 2, name: "position", kind: "message", T: () => Vector3d },
            { no: 3, name: "orientation", kind: "message", T: () => Orientation3d }
        ]);
    }
    create(value?: PartialMessage<StatePoint>): StatePoint {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StatePoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatePoint): StatePoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional osi3.Timestamp timestamp */ 1:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* optional osi3.Vector3d position */ 2:
                    message.position = Vector3d.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional osi3.Orientation3d orientation */ 3:
                    message.orientation = Orientation3d.internalBinaryRead(reader, reader.uint32(), options, message.orientation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatePoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional osi3.Timestamp timestamp = 1; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Vector3d position = 2; */
        if (message.position)
            Vector3d.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.Orientation3d orientation = 3; */
        if (message.orientation)
            Orientation3d.internalBinaryWrite(message.orientation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.StatePoint
 */
export const StatePoint = new StatePoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WavelengthData$Type extends MessageType<WavelengthData> {
    constructor() {
        super("osi3.WavelengthData", [
            { no: 1, name: "start", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "end", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "samples_number", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<WavelengthData>): WavelengthData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WavelengthData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WavelengthData): WavelengthData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double start */ 1:
                    message.start = reader.double();
                    break;
                case /* optional double end */ 2:
                    message.end = reader.double();
                    break;
                case /* optional double samples_number */ 3:
                    message.samplesNumber = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WavelengthData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double start = 1; */
        if (message.start !== undefined)
            writer.tag(1, WireType.Bit64).double(message.start);
        /* optional double end = 2; */
        if (message.end !== undefined)
            writer.tag(2, WireType.Bit64).double(message.end);
        /* optional double samples_number = 3; */
        if (message.samplesNumber !== undefined)
            writer.tag(3, WireType.Bit64).double(message.samplesNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.WavelengthData
 */
export const WavelengthData = new WavelengthData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpatialSignalStrength$Type extends MessageType<SpatialSignalStrength> {
    constructor() {
        super("osi3.SpatialSignalStrength", [
            { no: 1, name: "horizontal_angle", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "vertical_angle", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "signal_strength", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SpatialSignalStrength>): SpatialSignalStrength {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpatialSignalStrength>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpatialSignalStrength): SpatialSignalStrength {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double horizontal_angle */ 1:
                    message.horizontalAngle = reader.double();
                    break;
                case /* optional double vertical_angle */ 2:
                    message.verticalAngle = reader.double();
                    break;
                case /* optional double signal_strength */ 3:
                    message.signalStrength = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpatialSignalStrength, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double horizontal_angle = 1; */
        if (message.horizontalAngle !== undefined)
            writer.tag(1, WireType.Bit64).double(message.horizontalAngle);
        /* optional double vertical_angle = 2; */
        if (message.verticalAngle !== undefined)
            writer.tag(2, WireType.Bit64).double(message.verticalAngle);
        /* optional double signal_strength = 3; */
        if (message.signalStrength !== undefined)
            writer.tag(3, WireType.Bit64).double(message.signalStrength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.SpatialSignalStrength
 */
export const SpatialSignalStrength = new SpatialSignalStrength$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorDescription$Type extends MessageType<ColorDescription> {
    constructor() {
        super("osi3.ColorDescription", [
            { no: 1, name: "grey", kind: "message", T: () => ColorGrey },
            { no: 2, name: "rgb", kind: "message", T: () => ColorRGB },
            { no: 3, name: "rgbir", kind: "message", T: () => ColorRGBIR },
            { no: 4, name: "hsv", kind: "message", T: () => ColorHSV },
            { no: 5, name: "luv", kind: "message", T: () => ColorLUV },
            { no: 6, name: "cmyk", kind: "message", T: () => ColorCMYK }
        ]);
    }
    create(value?: PartialMessage<ColorDescription>): ColorDescription {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ColorDescription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorDescription): ColorDescription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional osi3.ColorGrey grey */ 1:
                    message.grey = ColorGrey.internalBinaryRead(reader, reader.uint32(), options, message.grey);
                    break;
                case /* optional osi3.ColorRGB rgb */ 2:
                    message.rgb = ColorRGB.internalBinaryRead(reader, reader.uint32(), options, message.rgb);
                    break;
                case /* optional osi3.ColorRGBIR rgbir */ 3:
                    message.rgbir = ColorRGBIR.internalBinaryRead(reader, reader.uint32(), options, message.rgbir);
                    break;
                case /* optional osi3.ColorHSV hsv */ 4:
                    message.hsv = ColorHSV.internalBinaryRead(reader, reader.uint32(), options, message.hsv);
                    break;
                case /* optional osi3.ColorLUV luv */ 5:
                    message.luv = ColorLUV.internalBinaryRead(reader, reader.uint32(), options, message.luv);
                    break;
                case /* optional osi3.ColorCMYK cmyk */ 6:
                    message.cmyk = ColorCMYK.internalBinaryRead(reader, reader.uint32(), options, message.cmyk);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColorDescription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional osi3.ColorGrey grey = 1; */
        if (message.grey)
            ColorGrey.internalBinaryWrite(message.grey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.ColorRGB rgb = 2; */
        if (message.rgb)
            ColorRGB.internalBinaryWrite(message.rgb, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.ColorRGBIR rgbir = 3; */
        if (message.rgbir)
            ColorRGBIR.internalBinaryWrite(message.rgbir, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.ColorHSV hsv = 4; */
        if (message.hsv)
            ColorHSV.internalBinaryWrite(message.hsv, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.ColorLUV luv = 5; */
        if (message.luv)
            ColorLUV.internalBinaryWrite(message.luv, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional osi3.ColorCMYK cmyk = 6; */
        if (message.cmyk)
            ColorCMYK.internalBinaryWrite(message.cmyk, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.ColorDescription
 */
export const ColorDescription = new ColorDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorGrey$Type extends MessageType<ColorGrey> {
    constructor() {
        super("osi3.ColorGrey", [
            { no: 1, name: "grey", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ColorGrey>): ColorGrey {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ColorGrey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorGrey): ColorGrey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double grey */ 1:
                    message.grey = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColorGrey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double grey = 1; */
        if (message.grey !== undefined)
            writer.tag(1, WireType.Bit64).double(message.grey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.ColorGrey
 */
export const ColorGrey = new ColorGrey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorRGB$Type extends MessageType<ColorRGB> {
    constructor() {
        super("osi3.ColorRGB", [
            { no: 1, name: "red", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "green", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "blue", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ColorRGB>): ColorRGB {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ColorRGB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorRGB): ColorRGB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double red */ 1:
                    message.red = reader.double();
                    break;
                case /* optional double green */ 2:
                    message.green = reader.double();
                    break;
                case /* optional double blue */ 3:
                    message.blue = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColorRGB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double red = 1; */
        if (message.red !== undefined)
            writer.tag(1, WireType.Bit64).double(message.red);
        /* optional double green = 2; */
        if (message.green !== undefined)
            writer.tag(2, WireType.Bit64).double(message.green);
        /* optional double blue = 3; */
        if (message.blue !== undefined)
            writer.tag(3, WireType.Bit64).double(message.blue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.ColorRGB
 */
export const ColorRGB = new ColorRGB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorRGBIR$Type extends MessageType<ColorRGBIR> {
    constructor() {
        super("osi3.ColorRGBIR", [
            { no: 1, name: "red", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "green", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "blue", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "infrared", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ColorRGBIR>): ColorRGBIR {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ColorRGBIR>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorRGBIR): ColorRGBIR {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double red */ 1:
                    message.red = reader.double();
                    break;
                case /* optional double green */ 2:
                    message.green = reader.double();
                    break;
                case /* optional double blue */ 3:
                    message.blue = reader.double();
                    break;
                case /* optional double infrared */ 4:
                    message.infrared = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColorRGBIR, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double red = 1; */
        if (message.red !== undefined)
            writer.tag(1, WireType.Bit64).double(message.red);
        /* optional double green = 2; */
        if (message.green !== undefined)
            writer.tag(2, WireType.Bit64).double(message.green);
        /* optional double blue = 3; */
        if (message.blue !== undefined)
            writer.tag(3, WireType.Bit64).double(message.blue);
        /* optional double infrared = 4; */
        if (message.infrared !== undefined)
            writer.tag(4, WireType.Bit64).double(message.infrared);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.ColorRGBIR
 */
export const ColorRGBIR = new ColorRGBIR$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorHSV$Type extends MessageType<ColorHSV> {
    constructor() {
        super("osi3.ColorHSV", [
            { no: 1, name: "hue", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "saturation", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ColorHSV>): ColorHSV {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ColorHSV>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorHSV): ColorHSV {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double hue */ 1:
                    message.hue = reader.double();
                    break;
                case /* optional double saturation */ 2:
                    message.saturation = reader.double();
                    break;
                case /* optional double value */ 3:
                    message.value = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColorHSV, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double hue = 1; */
        if (message.hue !== undefined)
            writer.tag(1, WireType.Bit64).double(message.hue);
        /* optional double saturation = 2; */
        if (message.saturation !== undefined)
            writer.tag(2, WireType.Bit64).double(message.saturation);
        /* optional double value = 3; */
        if (message.value !== undefined)
            writer.tag(3, WireType.Bit64).double(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.ColorHSV
 */
export const ColorHSV = new ColorHSV$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorLUV$Type extends MessageType<ColorLUV> {
    constructor() {
        super("osi3.ColorLUV", [
            { no: 1, name: "luminance", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "u", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "v", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ColorLUV>): ColorLUV {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ColorLUV>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorLUV): ColorLUV {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double luminance */ 1:
                    message.luminance = reader.double();
                    break;
                case /* optional double u */ 2:
                    message.u = reader.double();
                    break;
                case /* optional double v */ 3:
                    message.v = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColorLUV, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double luminance = 1; */
        if (message.luminance !== undefined)
            writer.tag(1, WireType.Bit64).double(message.luminance);
        /* optional double u = 2; */
        if (message.u !== undefined)
            writer.tag(2, WireType.Bit64).double(message.u);
        /* optional double v = 3; */
        if (message.v !== undefined)
            writer.tag(3, WireType.Bit64).double(message.v);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.ColorLUV
 */
export const ColorLUV = new ColorLUV$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColorCMYK$Type extends MessageType<ColorCMYK> {
    constructor() {
        super("osi3.ColorCMYK", [
            { no: 1, name: "cyan", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "magenta", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "yellow", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "key", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ColorCMYK>): ColorCMYK {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ColorCMYK>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColorCMYK): ColorCMYK {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double cyan */ 1:
                    message.cyan = reader.double();
                    break;
                case /* optional double magenta */ 2:
                    message.magenta = reader.double();
                    break;
                case /* optional double yellow */ 3:
                    message.yellow = reader.double();
                    break;
                case /* optional double key */ 4:
                    message.key = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColorCMYK, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double cyan = 1; */
        if (message.cyan !== undefined)
            writer.tag(1, WireType.Bit64).double(message.cyan);
        /* optional double magenta = 2; */
        if (message.magenta !== undefined)
            writer.tag(2, WireType.Bit64).double(message.magenta);
        /* optional double yellow = 3; */
        if (message.yellow !== undefined)
            writer.tag(3, WireType.Bit64).double(message.yellow);
        /* optional double key = 4; */
        if (message.key !== undefined)
            writer.tag(4, WireType.Bit64).double(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.ColorCMYK
 */
export const ColorCMYK = new ColorCMYK$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pedalry$Type extends MessageType<Pedalry> {
    constructor() {
        super("osi3.Pedalry", [
            { no: 1, name: "pedal_position_acceleration", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "pedal_position_brake", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "pedal_position_clutch", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Pedalry>): Pedalry {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Pedalry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pedalry): Pedalry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double pedal_position_acceleration */ 1:
                    message.pedalPositionAcceleration = reader.double();
                    break;
                case /* optional double pedal_position_brake */ 2:
                    message.pedalPositionBrake = reader.double();
                    break;
                case /* optional double pedal_position_clutch */ 3:
                    message.pedalPositionClutch = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pedalry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double pedal_position_acceleration = 1; */
        if (message.pedalPositionAcceleration !== undefined)
            writer.tag(1, WireType.Bit64).double(message.pedalPositionAcceleration);
        /* optional double pedal_position_brake = 2; */
        if (message.pedalPositionBrake !== undefined)
            writer.tag(2, WireType.Bit64).double(message.pedalPositionBrake);
        /* optional double pedal_position_clutch = 3; */
        if (message.pedalPositionClutch !== undefined)
            writer.tag(3, WireType.Bit64).double(message.pedalPositionClutch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.Pedalry
 */
export const Pedalry = new Pedalry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VehicleSteeringWheel$Type extends MessageType<VehicleSteeringWheel> {
    constructor() {
        super("osi3.VehicleSteeringWheel", [
            { no: 1, name: "angle", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "angular_speed", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "torque", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<VehicleSteeringWheel>): VehicleSteeringWheel {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VehicleSteeringWheel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VehicleSteeringWheel): VehicleSteeringWheel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double angle */ 1:
                    message.angle = reader.double();
                    break;
                case /* optional double angular_speed */ 2:
                    message.angularSpeed = reader.double();
                    break;
                case /* optional double torque */ 3:
                    message.torque = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VehicleSteeringWheel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double angle = 1; */
        if (message.angle !== undefined)
            writer.tag(1, WireType.Bit64).double(message.angle);
        /* optional double angular_speed = 2; */
        if (message.angularSpeed !== undefined)
            writer.tag(2, WireType.Bit64).double(message.angularSpeed);
        /* optional double torque = 3; */
        if (message.torque !== undefined)
            writer.tag(3, WireType.Bit64).double(message.torque);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.VehicleSteeringWheel
 */
export const VehicleSteeringWheel = new VehicleSteeringWheel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GeodeticPosition$Type extends MessageType<GeodeticPosition> {
    constructor() {
        super("osi3.GeodeticPosition", [
            { no: 1, name: "longitude", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "latitude", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "altitude", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<GeodeticPosition>): GeodeticPosition {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GeodeticPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GeodeticPosition): GeodeticPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double longitude */ 1:
                    message.longitude = reader.double();
                    break;
                case /* optional double latitude */ 2:
                    message.latitude = reader.double();
                    break;
                case /* optional double altitude */ 3:
                    message.altitude = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GeodeticPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional double longitude = 1; */
        if (message.longitude !== undefined)
            writer.tag(1, WireType.Bit64).double(message.longitude);
        /* optional double latitude = 2; */
        if (message.latitude !== undefined)
            writer.tag(2, WireType.Bit64).double(message.latitude);
        /* optional double altitude = 3; */
        if (message.altitude !== undefined)
            writer.tag(3, WireType.Bit64).double(message.altitude);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message osi3.GeodeticPosition
 */
export const GeodeticPosition = new GeodeticPosition$Type();
