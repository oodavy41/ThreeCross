// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "perception_msg.proto" (package "ec.PerceptionMsg", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message ec.PerceptionMsg.Header
 */
export interface Header {
    /**
     * @generated from protobuf field: optional uint64 timestamp = 1;
     */
    timestamp?: bigint; // 消息的时间戳
    /**
     * @generated from protobuf field: optional uint32 frame_id = 2;
     */
    frameId?: number; // 消息的帧id
}
/**
 * @generated from protobuf message ec.PerceptionMsg.BBox
 */
export interface BBox {
    /**
     * @generated from protobuf field: optional float x1 = 1;
     */
    x1?: number; // 检测到的对象的bounding box的左侧在camera图像像素上的坐标
    /**
     * @generated from protobuf field: optional float y1 = 2;
     */
    y1?: number; // 检测到的对象的bounding box的上侧在camera图像像素上的坐标
    /**
     * @generated from protobuf field: optional float x2 = 3;
     */
    x2?: number; // 检测到的对象的bounding box的右侧在camera图像像素上的坐标
    /**
     * @generated from protobuf field: optional float y2 = 4;
     */
    y2?: number; // 检测到的对象的bounding box的下侧在camera图像像素上的坐标
}
/**
 * @generated from protobuf message ec.PerceptionMsg.Classification
 */
export interface Classification {
    /**
     * @generated from protobuf field: optional ec.PerceptionMsg.ObjectType type = 1;
     */
    type?: ObjectType; // 类别id
    /**
     * @generated from protobuf field: optional float confidence_class = 2;
     */
    confidenceClass?: number; // 对象属于该类别的置信度
}
/**
 * @generated from protobuf message ec.PerceptionMsg.Status
 */
export interface Status {
    /**
     * @generated from protobuf field: optional ec.PerceptionMsg.BBox bbox = 1;
     */
    bbox?: BBox; // 检测到的对象在对应camera图像上的2D bounding box
    /**
     * @generated from protobuf field: optional int32 category_id = 2;
     */
    categoryId?: number; // 对象的类别id，参照 Object_type
    /**
     * @generated from protobuf field: optional float confidence = 3;
     */
    confidence?: number; // 置信度
    /**
     * @generated from protobuf field: repeated ec.PerceptionMsg.Classification classifications = 4;
     */
    classifications: Classification[]; // 对象属于各类别的置信度
    /**
     * @generated from protobuf field: optional float length = 5;
     */
    length?: number; // 长
    /**
     * @generated from protobuf field: optional float width = 6;
     */
    width?: number; // 宽
    /**
     * @generated from protobuf field: optional float height = 7;
     */
    height?: number; // 高
    /**
     * @generated from protobuf field: optional float length_var = 8;
     */
    lengthVar?: number; // 对象的长的方差（可信度）
    /**
     * @generated from protobuf field: optional float width_var = 9;
     */
    widthVar?: number; // 对象的宽的方差（可信度）
    /**
     * @generated from protobuf field: optional float position_cx = 10;
     */
    positionCx?: number; // 对象中心点在世界坐标系中地面上的x轴坐标
    /**
     * @generated from protobuf field: optional float position_cy = 11;
     */
    positionCy?: number; // 对象中心点在世界坐标系中地面上的y轴坐标
    /**
     * @generated from protobuf field: optional float yaw = 12;
     */
    yaw?: number; // 运动方向
    /**
     * @generated from protobuf field: optional float yaw_rate = 13;
     */
    yawRate?: number; // 角速度
    /**
     * @generated from protobuf field: optional float velocity_x = 14;
     */
    velocityX?: number; // 世界坐标系中速度的x分量
    /**
     * @generated from protobuf field: optional float velocity_y = 15;
     */
    velocityY?: number; // 世界坐标系中速度的y分量
    /**
     * @generated from protobuf field: optional float velocity_x_var = 16;
     */
    velocityXVar?: number; // 世界坐标系中速度的x分量的方差（可信度）
    /**
     * @generated from protobuf field: optional float velocity_y_var = 17;
     */
    velocityYVar?: number; // 世界坐标系中速度的y分量的方差（可信度）
    /**
     * @generated from protobuf field: optional float acceleration_x = 18;
     */
    accelerationX?: number; // 世界坐标系中加速度的x分量
    /**
     * @generated from protobuf field: optional float acceleration_y = 19;
     */
    accelerationY?: number; // 世界坐标系中加速度的y分量
    /**
     * @generated from protobuf field: optional int32 lane_id = 20;
     */
    laneId?: number; // 该对象当前所在的车道的id
    /**
     * @generated from protobuf field: optional string license_id = 21;
     */
    licenseId?: string; // 该对象的车牌
}
/**
 * @generated from protobuf message ec.PerceptionMsg.ObjectEvents
 */
export interface ObjectEvents {
    /**
     * @generated from protobuf field: optional bool overspeed = 1;
     */
    overspeed?: boolean; // 超速
    /**
     * @generated from protobuf field: optional bool underspeed = 2;
     */
    underspeed?: boolean; // 低速
    /**
     * @generated from protobuf field: optional bool intrusion = 3;
     */
    intrusion?: boolean; // 行人、动物、非机动车闯入
    /**
     * @generated from protobuf field: optional bool illegal_paking = 4;
     */
    illegalPaking?: boolean; // 异常停车
    /**
     * @generated from protobuf field: optional bool solid_line = 5;
     */
    solidLine?: boolean; // 实线变道
    /**
     * @generated from protobuf field: optional bool emergency_line = 6;
     */
    emergencyLine?: boolean; // 占用应急车道
    /**
     * @generated from protobuf field: optional bool box_junction = 7;
     */
    boxJunction?: boolean; // 穿越导流区
    /**
     * @generated from protobuf field: optional bool small_car_lane = 8;
     */
    smallCarLane?: boolean; // 大车占小车道
    /**
     * @generated from protobuf field: optional bool wrong_direction = 9;
     */
    wrongDirection?: boolean; // 逆行
}
/**
 * @generated from protobuf message ec.PerceptionMsg.Object
 */
export interface Object {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number; // 检测到的对象的id
    /**
     * @generated from protobuf field: uint64 time_stamp = 2;
     */
    timeStamp: bigint; // 该对象对应的传感器的时间戳
    /**
     * @generated from protobuf field: optional string sensor_type = 3;
     */
    sensorType?: string; // 检测到该对象的传感器，例如【camera 0、1…n，cv_fusion, radar 0…，lidar 0…，global_fusion 】
    /**
     * @generated from protobuf field: optional ec.PerceptionMsg.Status status = 4;
     */
    status?: Status; // 目标级检测的结果
    /**
     * @generated from protobuf field: optional ec.PerceptionMsg.ObjectEvents obj_events = 5;
     */
    objEvents?: ObjectEvents; // 事件级检测的结果
}
/**
 * @generated from protobuf message ec.PerceptionMsg.TrafficFlow
 */
export interface TrafficFlow {
    /**
     * @generated from protobuf field: optional uint32 car_size = 1;
     */
    carSize?: number; // 小轿车数量(car、suv)
    /**
     * @generated from protobuf field: optional uint32 bus_size = 2;
     */
    busSize?: number; // 客车数量(bus、van)
    /**
     * @generated from protobuf field: optional uint32 truck_size = 3;
     */
    truckSize?: number; // 货车数量
}
/**
 * @generated from protobuf message ec.PerceptionMsg.Lane
 */
export interface Lane {
    /**
     * @generated from protobuf field: uint32 lane_id = 1;
     */
    laneId: number; // 车道id
    /**
     * @generated from protobuf field: optional ec.PerceptionMsg.TrafficFlow traffic_flow = 2;
     */
    trafficFlow?: TrafficFlow; // 交通流量信息
    /**
     * @generated from protobuf field: optional float average_speed = 3;
     */
    averageSpeed?: number; // 平均速度
    /**
     * @generated from protobuf field: optional bool traffic_jam = 4;
     */
    trafficJam?: boolean; // 交通拥堵
    /**
     * @generated from protobuf field: optional float headway = 5;
     */
    headway?: number; // 车头时距
    /**
     * @generated from protobuf field: optional float time_occupancy = 6;
     */
    timeOccupancy?: number; // 时间占有率
    /**
     * @generated from protobuf field: optional float space_occupancy = 7;
     */
    spaceOccupancy?: number; // 空间占有率
    /**
     * @generated from protobuf field: optional float queue_length = 8;
     */
    queueLength?: number; // 排队长度
}
/**
 * @generated from protobuf message ec.PerceptionMsg.OutMsg
 */
export interface OutMsg {
    /**
     * @generated from protobuf field: optional ec.PerceptionMsg.Header header = 1;
     */
    header?: Header; // 消息头
    /**
     * @generated from protobuf field: repeated ec.PerceptionMsg.Object objects = 2;
     */
    objects: Object[]; // 检测到的目标对象
    /**
     * @generated from protobuf field: repeated ec.PerceptionMsg.Lane lanes = 3;
     */
    lanes: Lane[]; // 车道信息
}
/**
 * @generated from protobuf enum ec.PerceptionMsg.ObjectType
 */
export enum ObjectType {
    /**
     * @generated from protobuf enum value: CAR = 0;
     */
    CAR = 0,
    /**
     * @generated from protobuf enum value: BUS = 1;
     */
    BUS = 1,
    /**
     * @generated from protobuf enum value: TRUCK = 2;
     */
    TRUCK = 2,
    /**
     * @generated from protobuf enum value: PEDESTRIANS = 3;
     */
    PEDESTRIANS = 3,
    /**
     * @generated from protobuf enum value: CYCLIST = 4;
     */
    CYCLIST = 4,
    /**
     * @generated from protobuf enum value: MOTORCYCLE = 5;
     */
    MOTORCYCLE = 5,
    /**
     * @generated from protobuf enum value: UNKNOWN = 6;
     */
    UNKNOWN = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class Header$Type extends MessageType<Header> {
    constructor() {
        super("ec.PerceptionMsg.Header", [
            { no: 1, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "frame_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Header>): Header {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Header): Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 timestamp */ 1:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 frame_id */ 2:
                    message.frameId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 timestamp = 1; */
        if (message.timestamp !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.timestamp);
        /* optional uint32 frame_id = 2; */
        if (message.frameId !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.frameId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.Header
 */
export const Header = new Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BBox$Type extends MessageType<BBox> {
    constructor() {
        super("ec.PerceptionMsg.BBox", [
            { no: 1, name: "x1", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y1", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "x2", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y2", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<BBox>): BBox {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BBox>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BBox): BBox {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x1 */ 1:
                    message.x1 = reader.float();
                    break;
                case /* optional float y1 */ 2:
                    message.y1 = reader.float();
                    break;
                case /* optional float x2 */ 3:
                    message.x2 = reader.float();
                    break;
                case /* optional float y2 */ 4:
                    message.y2 = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BBox, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x1 = 1; */
        if (message.x1 !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x1);
        /* optional float y1 = 2; */
        if (message.y1 !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y1);
        /* optional float x2 = 3; */
        if (message.x2 !== undefined)
            writer.tag(3, WireType.Bit32).float(message.x2);
        /* optional float y2 = 4; */
        if (message.y2 !== undefined)
            writer.tag(4, WireType.Bit32).float(message.y2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.BBox
 */
export const BBox = new BBox$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Classification$Type extends MessageType<Classification> {
    constructor() {
        super("ec.PerceptionMsg.Classification", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["ec.PerceptionMsg.ObjectType", ObjectType] },
            { no: 2, name: "confidence_class", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Classification>): Classification {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Classification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Classification): Classification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ec.PerceptionMsg.ObjectType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional float confidence_class */ 2:
                    message.confidenceClass = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Classification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ec.PerceptionMsg.ObjectType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional float confidence_class = 2; */
        if (message.confidenceClass !== undefined)
            writer.tag(2, WireType.Bit32).float(message.confidenceClass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.Classification
 */
export const Classification = new Classification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("ec.PerceptionMsg.Status", [
            { no: 1, name: "bbox", kind: "message", T: () => BBox },
            { no: 2, name: "category_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "confidence", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "classifications", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Classification },
            { no: 5, name: "length", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "height", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "length_var", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "width_var", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "position_cx", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "position_cy", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "yaw", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "yaw_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "velocity_x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "velocity_y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "velocity_x_var", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 17, name: "velocity_y_var", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 18, name: "acceleration_x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 19, name: "acceleration_y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "lane_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "license_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = { classifications: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ec.PerceptionMsg.BBox bbox */ 1:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* optional int32 category_id */ 2:
                    message.categoryId = reader.int32();
                    break;
                case /* optional float confidence */ 3:
                    message.confidence = reader.float();
                    break;
                case /* repeated ec.PerceptionMsg.Classification classifications */ 4:
                    message.classifications.push(Classification.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float length */ 5:
                    message.length = reader.float();
                    break;
                case /* optional float width */ 6:
                    message.width = reader.float();
                    break;
                case /* optional float height */ 7:
                    message.height = reader.float();
                    break;
                case /* optional float length_var */ 8:
                    message.lengthVar = reader.float();
                    break;
                case /* optional float width_var */ 9:
                    message.widthVar = reader.float();
                    break;
                case /* optional float position_cx */ 10:
                    message.positionCx = reader.float();
                    break;
                case /* optional float position_cy */ 11:
                    message.positionCy = reader.float();
                    break;
                case /* optional float yaw */ 12:
                    message.yaw = reader.float();
                    break;
                case /* optional float yaw_rate */ 13:
                    message.yawRate = reader.float();
                    break;
                case /* optional float velocity_x */ 14:
                    message.velocityX = reader.float();
                    break;
                case /* optional float velocity_y */ 15:
                    message.velocityY = reader.float();
                    break;
                case /* optional float velocity_x_var */ 16:
                    message.velocityXVar = reader.float();
                    break;
                case /* optional float velocity_y_var */ 17:
                    message.velocityYVar = reader.float();
                    break;
                case /* optional float acceleration_x */ 18:
                    message.accelerationX = reader.float();
                    break;
                case /* optional float acceleration_y */ 19:
                    message.accelerationY = reader.float();
                    break;
                case /* optional int32 lane_id */ 20:
                    message.laneId = reader.int32();
                    break;
                case /* optional string license_id */ 21:
                    message.licenseId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ec.PerceptionMsg.BBox bbox = 1; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 category_id = 2; */
        if (message.categoryId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.categoryId);
        /* optional float confidence = 3; */
        if (message.confidence !== undefined)
            writer.tag(3, WireType.Bit32).float(message.confidence);
        /* repeated ec.PerceptionMsg.Classification classifications = 4; */
        for (let i = 0; i < message.classifications.length; i++)
            Classification.internalBinaryWrite(message.classifications[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional float length = 5; */
        if (message.length !== undefined)
            writer.tag(5, WireType.Bit32).float(message.length);
        /* optional float width = 6; */
        if (message.width !== undefined)
            writer.tag(6, WireType.Bit32).float(message.width);
        /* optional float height = 7; */
        if (message.height !== undefined)
            writer.tag(7, WireType.Bit32).float(message.height);
        /* optional float length_var = 8; */
        if (message.lengthVar !== undefined)
            writer.tag(8, WireType.Bit32).float(message.lengthVar);
        /* optional float width_var = 9; */
        if (message.widthVar !== undefined)
            writer.tag(9, WireType.Bit32).float(message.widthVar);
        /* optional float position_cx = 10; */
        if (message.positionCx !== undefined)
            writer.tag(10, WireType.Bit32).float(message.positionCx);
        /* optional float position_cy = 11; */
        if (message.positionCy !== undefined)
            writer.tag(11, WireType.Bit32).float(message.positionCy);
        /* optional float yaw = 12; */
        if (message.yaw !== undefined)
            writer.tag(12, WireType.Bit32).float(message.yaw);
        /* optional float yaw_rate = 13; */
        if (message.yawRate !== undefined)
            writer.tag(13, WireType.Bit32).float(message.yawRate);
        /* optional float velocity_x = 14; */
        if (message.velocityX !== undefined)
            writer.tag(14, WireType.Bit32).float(message.velocityX);
        /* optional float velocity_y = 15; */
        if (message.velocityY !== undefined)
            writer.tag(15, WireType.Bit32).float(message.velocityY);
        /* optional float velocity_x_var = 16; */
        if (message.velocityXVar !== undefined)
            writer.tag(16, WireType.Bit32).float(message.velocityXVar);
        /* optional float velocity_y_var = 17; */
        if (message.velocityYVar !== undefined)
            writer.tag(17, WireType.Bit32).float(message.velocityYVar);
        /* optional float acceleration_x = 18; */
        if (message.accelerationX !== undefined)
            writer.tag(18, WireType.Bit32).float(message.accelerationX);
        /* optional float acceleration_y = 19; */
        if (message.accelerationY !== undefined)
            writer.tag(19, WireType.Bit32).float(message.accelerationY);
        /* optional int32 lane_id = 20; */
        if (message.laneId !== undefined)
            writer.tag(20, WireType.Varint).int32(message.laneId);
        /* optional string license_id = 21; */
        if (message.licenseId !== undefined)
            writer.tag(21, WireType.LengthDelimited).string(message.licenseId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectEvents$Type extends MessageType<ObjectEvents> {
    constructor() {
        super("ec.PerceptionMsg.ObjectEvents", [
            { no: 1, name: "overspeed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "underspeed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "intrusion", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "illegal_paking", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "solid_line", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "emergency_line", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "box_junction", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "small_car_lane", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "wrong_direction", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ObjectEvents>): ObjectEvents {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectEvents>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectEvents): ObjectEvents {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool overspeed */ 1:
                    message.overspeed = reader.bool();
                    break;
                case /* optional bool underspeed */ 2:
                    message.underspeed = reader.bool();
                    break;
                case /* optional bool intrusion */ 3:
                    message.intrusion = reader.bool();
                    break;
                case /* optional bool illegal_paking */ 4:
                    message.illegalPaking = reader.bool();
                    break;
                case /* optional bool solid_line */ 5:
                    message.solidLine = reader.bool();
                    break;
                case /* optional bool emergency_line */ 6:
                    message.emergencyLine = reader.bool();
                    break;
                case /* optional bool box_junction */ 7:
                    message.boxJunction = reader.bool();
                    break;
                case /* optional bool small_car_lane */ 8:
                    message.smallCarLane = reader.bool();
                    break;
                case /* optional bool wrong_direction */ 9:
                    message.wrongDirection = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObjectEvents, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool overspeed = 1; */
        if (message.overspeed !== undefined)
            writer.tag(1, WireType.Varint).bool(message.overspeed);
        /* optional bool underspeed = 2; */
        if (message.underspeed !== undefined)
            writer.tag(2, WireType.Varint).bool(message.underspeed);
        /* optional bool intrusion = 3; */
        if (message.intrusion !== undefined)
            writer.tag(3, WireType.Varint).bool(message.intrusion);
        /* optional bool illegal_paking = 4; */
        if (message.illegalPaking !== undefined)
            writer.tag(4, WireType.Varint).bool(message.illegalPaking);
        /* optional bool solid_line = 5; */
        if (message.solidLine !== undefined)
            writer.tag(5, WireType.Varint).bool(message.solidLine);
        /* optional bool emergency_line = 6; */
        if (message.emergencyLine !== undefined)
            writer.tag(6, WireType.Varint).bool(message.emergencyLine);
        /* optional bool box_junction = 7; */
        if (message.boxJunction !== undefined)
            writer.tag(7, WireType.Varint).bool(message.boxJunction);
        /* optional bool small_car_lane = 8; */
        if (message.smallCarLane !== undefined)
            writer.tag(8, WireType.Varint).bool(message.smallCarLane);
        /* optional bool wrong_direction = 9; */
        if (message.wrongDirection !== undefined)
            writer.tag(9, WireType.Varint).bool(message.wrongDirection);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.ObjectEvents
 */
export const ObjectEvents = new ObjectEvents$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object$Type extends MessageType<Object> {
    constructor() {
        super("ec.PerceptionMsg.Object", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "time_stamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sensor_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "message", T: () => Status },
            { no: 5, name: "obj_events", kind: "message", T: () => ObjectEvents }
        ]);
    }
    create(value?: PartialMessage<Object>): Object {
        const message = { id: 0, timeStamp: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Object>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object): Object {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint64 time_stamp */ 2:
                    message.timeStamp = reader.uint64().toBigInt();
                    break;
                case /* optional string sensor_type */ 3:
                    message.sensorType = reader.string();
                    break;
                case /* optional ec.PerceptionMsg.Status status */ 4:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* optional ec.PerceptionMsg.ObjectEvents obj_events */ 5:
                    message.objEvents = ObjectEvents.internalBinaryRead(reader, reader.uint32(), options, message.objEvents);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint64 time_stamp = 2; */
        if (message.timeStamp !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timeStamp);
        /* optional string sensor_type = 3; */
        if (message.sensorType !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.sensorType);
        /* optional ec.PerceptionMsg.Status status = 4; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional ec.PerceptionMsg.ObjectEvents obj_events = 5; */
        if (message.objEvents)
            ObjectEvents.internalBinaryWrite(message.objEvents, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.Object
 */
export const Object = new Object$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrafficFlow$Type extends MessageType<TrafficFlow> {
    constructor() {
        super("ec.PerceptionMsg.TrafficFlow", [
            { no: 1, name: "car_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "bus_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "truck_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TrafficFlow>): TrafficFlow {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrafficFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrafficFlow): TrafficFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 car_size */ 1:
                    message.carSize = reader.uint32();
                    break;
                case /* optional uint32 bus_size */ 2:
                    message.busSize = reader.uint32();
                    break;
                case /* optional uint32 truck_size */ 3:
                    message.truckSize = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrafficFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 car_size = 1; */
        if (message.carSize !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.carSize);
        /* optional uint32 bus_size = 2; */
        if (message.busSize !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.busSize);
        /* optional uint32 truck_size = 3; */
        if (message.truckSize !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.truckSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.TrafficFlow
 */
export const TrafficFlow = new TrafficFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Lane$Type extends MessageType<Lane> {
    constructor() {
        super("ec.PerceptionMsg.Lane", [
            { no: 1, name: "lane_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "traffic_flow", kind: "message", T: () => TrafficFlow },
            { no: 3, name: "average_speed", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "traffic_jam", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "headway", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "time_occupancy", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "space_occupancy", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "queue_length", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Lane>): Lane {
        const message = { laneId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Lane>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Lane): Lane {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 lane_id */ 1:
                    message.laneId = reader.uint32();
                    break;
                case /* optional ec.PerceptionMsg.TrafficFlow traffic_flow */ 2:
                    message.trafficFlow = TrafficFlow.internalBinaryRead(reader, reader.uint32(), options, message.trafficFlow);
                    break;
                case /* optional float average_speed */ 3:
                    message.averageSpeed = reader.float();
                    break;
                case /* optional bool traffic_jam */ 4:
                    message.trafficJam = reader.bool();
                    break;
                case /* optional float headway */ 5:
                    message.headway = reader.float();
                    break;
                case /* optional float time_occupancy */ 6:
                    message.timeOccupancy = reader.float();
                    break;
                case /* optional float space_occupancy */ 7:
                    message.spaceOccupancy = reader.float();
                    break;
                case /* optional float queue_length */ 8:
                    message.queueLength = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Lane, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 lane_id = 1; */
        if (message.laneId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.laneId);
        /* optional ec.PerceptionMsg.TrafficFlow traffic_flow = 2; */
        if (message.trafficFlow)
            TrafficFlow.internalBinaryWrite(message.trafficFlow, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional float average_speed = 3; */
        if (message.averageSpeed !== undefined)
            writer.tag(3, WireType.Bit32).float(message.averageSpeed);
        /* optional bool traffic_jam = 4; */
        if (message.trafficJam !== undefined)
            writer.tag(4, WireType.Varint).bool(message.trafficJam);
        /* optional float headway = 5; */
        if (message.headway !== undefined)
            writer.tag(5, WireType.Bit32).float(message.headway);
        /* optional float time_occupancy = 6; */
        if (message.timeOccupancy !== undefined)
            writer.tag(6, WireType.Bit32).float(message.timeOccupancy);
        /* optional float space_occupancy = 7; */
        if (message.spaceOccupancy !== undefined)
            writer.tag(7, WireType.Bit32).float(message.spaceOccupancy);
        /* optional float queue_length = 8; */
        if (message.queueLength !== undefined)
            writer.tag(8, WireType.Bit32).float(message.queueLength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.Lane
 */
export const Lane = new Lane$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutMsg$Type extends MessageType<OutMsg> {
    constructor() {
        super("ec.PerceptionMsg.OutMsg", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Object },
            { no: 3, name: "lanes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Lane }
        ]);
    }
    create(value?: PartialMessage<OutMsg>): OutMsg {
        const message = { objects: [], lanes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OutMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutMsg): OutMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ec.PerceptionMsg.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated ec.PerceptionMsg.Object objects */ 2:
                    message.objects.push(Object.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ec.PerceptionMsg.Lane lanes */ 3:
                    message.lanes.push(Lane.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ec.PerceptionMsg.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ec.PerceptionMsg.Object objects = 2; */
        for (let i = 0; i < message.objects.length; i++)
            Object.internalBinaryWrite(message.objects[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated ec.PerceptionMsg.Lane lanes = 3; */
        for (let i = 0; i < message.lanes.length; i++)
            Lane.internalBinaryWrite(message.lanes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.PerceptionMsg.OutMsg
 */
export const OutMsg = new OutMsg$Type();
