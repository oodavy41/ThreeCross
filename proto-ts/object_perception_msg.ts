// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "object_perception_msg.proto" (package "ec.perception", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * 目标级感知的内部消息的消息头，包含消息的基础信息
 *
 * @generated from protobuf message ec.perception.Header
 */
export interface Header {
    /**
     * @generated from protobuf field: optional uint32 frame_id = 1;
     */
    frameId?: number; // 帧id。注意！可能来自上游传感器，也可能来自消息的发出节点，规则自定。主要用于调试，谨慎用于算法
    /**
     * @generated from protobuf field: optional uint64 timestamp = 2;
     */
    timestamp?: bigint; // 时间戳。注意！可能来自上游传感器，也可能来自消息的发出节点。主要用于调试，谨慎用于算法
    /**
     * @generated from protobuf field: optional int32 sensor_id = 3;
     */
    sensorId?: number; // 源传感器的id。表示消息发出节点主要处理哪路传感器。如果处理多路传感器，基于主传感器，或整体置信度更高的传感器等策略决定
    /**
     * @generated from protobuf field: optional ec.perception.MsgStatus status = 4;
     */
    status?: MsgStatus; // 用于标记消息发出节点是否正常工作
}
/**
 * 图像坐标，目标2d bounding box
 *
 * @generated from protobuf message ec.perception.Box2d
 */
export interface Box2d {
    /**
     * @generated from protobuf field: optional float x1 = 1;
     */
    x1?: number; // 左上角x
    /**
     * @generated from protobuf field: optional float y1 = 2;
     */
    y1?: number; // 左上角y
    /**
     * @generated from protobuf field: optional float x2 = 3;
     */
    x2?: number; // 右下角x
    /**
     * @generated from protobuf field: optional float y2 = 4;
     */
    y2?: number; // 右下角y
}
/**
 * 图像坐标，目标3d bounding box
 *
 * @generated from protobuf message ec.perception.Box3d
 */
export interface Box3d {
    /**
     * @generated from protobuf field: optional float up_x1 = 1;
     */
    upX1?: number;
    /**
     * @generated from protobuf field: optional float up_y1 = 2;
     */
    upY1?: number;
    /**
     * @generated from protobuf field: optional float up_x2 = 3;
     */
    upX2?: number;
    /**
     * @generated from protobuf field: optional float up_y2 = 4;
     */
    upY2?: number;
    /**
     * @generated from protobuf field: optional float up_x3 = 5;
     */
    upX3?: number;
    /**
     * @generated from protobuf field: optional float up_y3 = 6;
     */
    upY3?: number;
    /**
     * @generated from protobuf field: optional float up_x4 = 7;
     */
    upX4?: number;
    /**
     * @generated from protobuf field: optional float up_y4 = 8;
     */
    upY4?: number;
    /**
     * @generated from protobuf field: optional float bottom_x1 = 9;
     */
    bottomX1?: number;
    /**
     * @generated from protobuf field: optional float bottom_y1 = 10;
     */
    bottomY1?: number;
    /**
     * @generated from protobuf field: optional float bottom_x2 = 11;
     */
    bottomX2?: number;
    /**
     * @generated from protobuf field: optional float bottom_y2 = 12;
     */
    bottomY2?: number;
    /**
     * @generated from protobuf field: optional float bottom_x3 = 13;
     */
    bottomX3?: number;
    /**
     * @generated from protobuf field: optional float bottom_y3 = 14;
     */
    bottomY3?: number;
    /**
     * @generated from protobuf field: optional float bottom_x4 = 15;
     */
    bottomX4?: number;
    /**
     * @generated from protobuf field: optional float bottom_y4 = 16;
     */
    bottomY4?: number;
}
/**
 * 图像坐标，用于3d信息计算的目标参考点
 *
 * @generated from protobuf message ec.perception.BoxRef3d
 */
export interface BoxRef3d {
    /**
     * @generated from protobuf field: optional float angle_x = 1;
     */
    angleX?: number;
    /**
     * @generated from protobuf field: optional float angle_y = 2;
     */
    angleY?: number;
    /**
     * @generated from protobuf field: optional float front_x = 3;
     */
    frontX?: number;
    /**
     * @generated from protobuf field: optional float front_y = 4;
     */
    frontY?: number;
    /**
     * @generated from protobuf field: optional float rear_x = 5;
     */
    rearX?: number;
    /**
     * @generated from protobuf field: optional float rear_y = 6;
     */
    rearY?: number;
}
/**
 * 图像坐标，目标框信息
 *
 * @generated from protobuf message ec.perception.BBox
 */
export interface BBox {
    /**
     * @generated from protobuf field: optional ec.perception.Box2d box_2d = 1 [json_name = "box2d"];
     */
    box2D?: Box2d; // 图像坐标，目标2d bounding box
    /**
     * @generated from protobuf field: optional ec.perception.Box3d box_3d = 2 [json_name = "box3d"];
     */
    box3D?: Box3d; // 图像坐标，目标3d bounding box
    /**
     * @generated from protobuf field: optional ec.perception.BoxRef3d box_ref = 3;
     */
    boxRef?: BoxRef3d; // 图像坐标，用于3d信息计算的目标参考点
    /**
     * @generated from protobuf field: optional float box_score = 4;
     */
    boxScore?: number; // 目标框的可信度，值越大越可信，规则由算法自定
}
/**
 * 车牌上的单个字符对应的id，以及置信度
 *
 * @generated from protobuf message ec.perception.Letter
 */
export interface Letter {
    /**
     * @generated from protobuf field: optional int32 character_id = 1;
     */
    characterId?: number; // 字符对应的id号
    /**
     * @generated from protobuf field: optional float score = 2;
     */
    score?: number; // 置信度
}
/**
 * 车牌信息
 *
 * @generated from protobuf message ec.perception.LicensePlate
 */
export interface LicensePlate {
    /**
     * @generated from protobuf field: optional string license_id = 1;
     */
    licenseId?: string; // 完整车牌
    /**
     * @generated from protobuf field: optional float confidence = 2;
     */
    confidence?: number; // 整个车牌识别结果的置信度
    /**
     * @generated from protobuf field: optional ec.perception.Box2d plate_box = 3;
     */
    plateBox?: Box2d; // 图像坐标上车牌的bounding box
    /**
     * @generated from protobuf field: repeated ec.perception.Letter letters = 4;
     */
    letters: Letter[]; // 车牌上的单个字符对应的id，以及置信度
    /**
     * @generated from protobuf field: optional bytes img_data = 5;
     */
    imgData?: Uint8Array; // 单个车牌图像数据，用于车牌识别模型的输入
}
/**
 * 感知到的目标的信息
 *
 * @generated from protobuf message ec.perception.Object
 */
export interface Object {
    /**
     * @generated from protobuf field: optional uint32 track_id = 1;
     */
    trackId?: number; // 目标的id
    /**
     * @generated from protobuf field: optional uint64 timestamp = 2;
     */
    timestamp?: bigint; // 用于检测该目标的源传感器数据的时间戳。注意！与 Header 的 timestamp 不一定相同
    /**
     * @generated from protobuf field: optional int32 sensor_id = 3;
     */
    sensorId?: number; // 源传感器的id
    /**
     * @generated from protobuf field: optional uint32 age = 4;
     */
    age?: number; // 存在时间（被感知到的次数）
    /**
     * @generated from protobuf field: optional ec.perception.MeasurementStatus measurement = 5;
     */
    measurement?: MeasurementStatus; // 目标的测量状态（被检测到的 / 跟丢的基于预测的 / 不可用的）
    /**
     * @generated from protobuf field: optional ec.perception.CategoryId category_id = 10;
     */
    categoryId?: CategoryId; // 目标最可能属于的类别
    /**
     * @generated from protobuf field: optional float confidence = 11;
     */
    confidence?: number; // 目标类别的置信度
    /**
     * @generated from protobuf field: repeated float all_confidence = 12;
     */
    allConfidence: number[]; // 目标各类别的置信度
    /**
     * @generated from protobuf field: optional ec.perception.BBox bbox = 20;
     */
    bbox?: BBox; // 图像坐标，目标框信息
    /**
     * @generated from protobuf field: optional float position_x = 30;
     */
    positionX?: number; // 世界坐标下的x位置坐标
    /**
     * @generated from protobuf field: optional float position_y = 31;
     */
    positionY?: number; // 世界坐标下的y位置坐标
    /**
     * @generated from protobuf field: optional float position_score = 32;
     */
    positionScore?: number; // 位置坐标的可信度，值越大越可信
    /**
     * @generated from protobuf field: optional ec.perception.OrientationType orientation_type = 40;
     */
    orientationType?: OrientationType; // 图像坐标上，目标的朝向类别。注意！是图像坐标上的
    /**
     * @generated from protobuf field: optional float orientation_score = 41;
     */
    orientationScore?: number; // 朝向的可信度，值越大越可信
    /**
     * @generated from protobuf field: optional float velocity_x = 50;
     */
    velocityX?: number; // 速度在世界坐标x分量上的大小，有正负
    /**
     * @generated from protobuf field: optional float velocity_y = 51;
     */
    velocityY?: number; // 速度在世界坐标y分量上的大小，有正负
    /**
     * @generated from protobuf field: optional float velocity_score = 52;
     */
    velocityScore?: number; // 速度的可信度，值越大越可信
    /**
     * @generated from protobuf field: optional float acceleration_x = 61;
     */
    accelerationX?: number; // 加速度在世界坐标x分量上的大小，有正负
    /**
     * @generated from protobuf field: optional float acceleration_y = 62;
     */
    accelerationY?: number; // 加速度在世界坐标y分量上的大小，有正负
    /**
     * @generated from protobuf field: optional float acceleration_score = 63;
     */
    accelerationScore?: number; // 加速度的可信度，值越大越可信
    /**
     * @generated from protobuf field: optional float length = 70;
     */
    length?: number; // 目标的长
    /**
     * @generated from protobuf field: optional float width = 71;
     */
    width?: number; // 宽
    /**
     * @generated from protobuf field: optional float height = 72;
     */
    height?: number; // 高
    /**
     * @generated from protobuf field: optional float dimension_score = 73;
     */
    dimensionScore?: number; // 三维尺寸的可信度，值越大越可信
    /**
     * @generated from protobuf field: optional ec.perception.CarLightStatus light_status = 80;
     */
    lightStatus?: CarLightStatus; // 车灯状态
    /**
     * @generated from protobuf field: optional float light_score = 81;
     */
    lightScore?: number; // 车灯状态的可信度，值越大越可信
    /**
     * @generated from protobuf field: optional int32 lane_id = 90;
     */
    laneId?: number; // 目标所在的车道的id
    /**
     * @generated from protobuf field: optional float lane_id_score = 91;
     */
    laneIdScore?: number; // 目标所在的车道的id可信度，值越大越可信
    /**
     * @generated from protobuf field: optional ec.perception.LicensePlate license_plate = 100;
     */
    licensePlate?: LicensePlate; // 车牌信息
}
/**
 * 用于目标检测模型的输入图像数据
 *
 * @generated from protobuf message ec.perception.SrcImage
 */
export interface SrcImage {
    /**
     * @generated from protobuf field: optional uint32 height = 1;
     */
    height?: number; // 图像的高
    /**
     * @generated from protobuf field: optional uint32 width = 2;
     */
    width?: number; // 图像的宽
    /**
     * @generated from protobuf field: optional uint32 node_id = 3;
     */
    nodeId?: number; // 1:net 2:3d 3:cvfusion
    /**
     * @generated from protobuf field: optional float fps = 4;
     */
    fps?: number; // 帧率
    /**
     * @generated from protobuf field: optional uint32 step = 5;
     */
    step?: number; // Full row length in bytes
    /**
     * @generated from protobuf field: optional bytes data = 6;
     */
    data?: Uint8Array; // actual matrix data, size is (step * rows)
}
/**
 * 目标级感知的内部消息，包含消息头、感知到的每个目标、用于感知的图像数据
 *
 * @generated from protobuf message ec.perception.ObjectMsg
 */
export interface ObjectMsg {
    /**
     * @generated from protobuf field: optional ec.perception.Header header = 1;
     */
    header?: Header; // 消息头，包含消息的基础信息
    /**
     * @generated from protobuf field: repeated ec.perception.Object objectlist = 2;
     */
    objectlist: Object[]; // 检测到的所有目标
    /**
     * @generated from protobuf field: optional int32 objects_num = 3;
     */
    objectsNum?: number; // 检测到的目标数。因为objectlist是repeated字段，自带size()函数接口可以返回目标个数，因此可以不使用此字段。<0表示未使用
    /**
     * @generated from protobuf field: optional ec.perception.SrcImage image_data = 4;
     */
    imageData?: SrcImage; // 用于目标检测模型的输入图像数据
}
/**
 * 用于标记消息发出节点是否正常工作
 *
 * @generated from protobuf enum ec.perception.MsgStatus
 */
export enum MsgStatus {
    /**
     * 节点工作正常，且能从上游节点接收正常数据
     *
     * @generated from protobuf enum value: GOOD = 0;
     */
    GOOD = 0,
    /**
     * @generated from protobuf enum value: MED = 1;
     */
    MED = 1,
    /**
     * 发出消息的节点无法正常工作，或者接收不到上游节点发送的正常数据
     *
     * @generated from protobuf enum value: ERROR = 2;
     */
    ERROR = 2
}
/**
 * 标记目标的测量状态
 *
 * @generated from protobuf enum ec.perception.MeasurementStatus
 */
export enum MeasurementStatus {
    /**
     * 目标的信息是被检测到的
     *
     * @generated from protobuf enum value: MEASURED = 0;
     */
    MEASURED = 0,
    /**
     * 目标的信息是基于先前的信息预测出来的，跟丢的可信预测
     *
     * @generated from protobuf enum value: PREDICTED = 1;
     */
    PREDICTED = 1,
    /**
     * @generated from protobuf enum value: NEW = 2;
     */
    NEW = 2,
    /**
     * 该目标的信息不可用
     *
     * @generated from protobuf enum value: INVALID = 3;
     */
    INVALID = 3
}
/**
 * 感知目标的类别
 *
 * @generated from protobuf enum ec.perception.CategoryId
 */
export enum CategoryId {
    /**
     * @generated from protobuf enum value: CAR = 0;
     */
    CAR = 0,
    /**
     * @generated from protobuf enum value: CAR_SUV = 1;
     */
    CAR_SUV = 1,
    /**
     * @generated from protobuf enum value: VAN = 2;
     */
    VAN = 2,
    /**
     * @generated from protobuf enum value: BUS = 3;
     */
    BUS = 3,
    /**
     * @generated from protobuf enum value: TRUCK = 4;
     */
    TRUCK = 4,
    /**
     * @generated from protobuf enum value: CAR_SPECIAL = 5;
     */
    CAR_SPECIAL = 5,
    /**
     * @generated from protobuf enum value: MOTORCYCLE = 6;
     */
    MOTORCYCLE = 6,
    /**
     * @generated from protobuf enum value: BICYCLE = 7;
     */
    BICYCLE = 7,
    /**
     * @generated from protobuf enum value: RIDER = 8;
     */
    RIDER = 8,
    /**
     * @generated from protobuf enum value: TRICYCLE = 9;
     */
    TRICYCLE = 9,
    /**
     * @generated from protobuf enum value: PEDESTRIAN = 10;
     */
    PEDESTRIAN = 10,
    /**
     * 交通灯
     *
     * @generated from protobuf enum value: TRAFFIC_SIGNS = 11;
     */
    TRAFFIC_SIGNS = 11,
    /**
     * @generated from protobuf enum value: TRAFFIC_CONE = 12;
     */
    TRAFFIC_CONE = 12,
    /**
     * @generated from protobuf enum value: UNKNOWN = 13;
     */
    UNKNOWN = 13,
    /**
     * 车牌
     *
     * @generated from protobuf enum value: PLATE = 14;
     */
    PLATE = 14,
    /**
     * @generated from protobuf enum value: FIRE = 15;
     */
    FIRE = 15,
    /**
     * @generated from protobuf enum value: SMOKE = 16;
     */
    SMOKE = 16
}
/**
 * 图像坐标上，目标的朝向类别。注意！是图像坐标上的
 *
 * @generated from protobuf enum ec.perception.OrientationType
 */
export enum OrientationType {
    /**
     * @generated from protobuf enum value: FRONT = 0;
     */
    FRONT = 0,
    /**
     * @generated from protobuf enum value: REAR = 1;
     */
    REAR = 1,
    /**
     * @generated from protobuf enum value: LEFT = 2;
     */
    LEFT = 2,
    /**
     * @generated from protobuf enum value: RIGHT = 3;
     */
    RIGHT = 3,
    /**
     * @generated from protobuf enum value: LEFT_FRONT = 4;
     */
    LEFT_FRONT = 4,
    /**
     * @generated from protobuf enum value: RIGHT_FRONT = 5;
     */
    RIGHT_FRONT = 5,
    /**
     * @generated from protobuf enum value: LEFT_REAR = 6;
     */
    LEFT_REAR = 6,
    /**
     * @generated from protobuf enum value: RIGHT_REAR = 7;
     */
    RIGHT_REAR = 7
}
/**
 * 车灯状态
 *
 * @generated from protobuf enum ec.perception.CarLightStatus
 */
export enum CarLightStatus {
    /**
     * 左转
     *
     * @generated from protobuf enum value: LEFT_SIGNAL = 0;
     */
    LEFT_SIGNAL = 0,
    /**
     * 右转
     *
     * @generated from protobuf enum value: RIGHT_SIGNAL = 1;
     */
    RIGHT_SIGNAL = 1,
    /**
     * 危险警报灯 / 双闪
     *
     * @generated from protobuf enum value: HAZARD_SIGNAL = 2;
     */
    HAZARD_SIGNAL = 2,
    /**
     * 刹车
     *
     * @generated from protobuf enum value: BRAKE_LIGHT = 3;
     */
    BRAKE_LIGHT = 3,
    /**
     * 倒车
     *
     * @generated from protobuf enum value: BACKUP_LIGHT = 4;
     */
    BACKUP_LIGHT = 4,
    /**
     * @generated from protobuf enum value: OTHER = 5;
     */
    OTHER = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class Header$Type extends MessageType<Header> {
    constructor() {
        super("ec.perception.Header", [
            { no: 1, name: "frame_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sensor_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "status", kind: "enum", opt: true, T: () => ["ec.perception.MsgStatus", MsgStatus] }
        ]);
    }
    create(value?: PartialMessage<Header>): Header {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Header): Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 frame_id */ 1:
                    message.frameId = reader.uint32();
                    break;
                case /* optional uint64 timestamp */ 2:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional int32 sensor_id */ 3:
                    message.sensorId = reader.int32();
                    break;
                case /* optional ec.perception.MsgStatus status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 frame_id = 1; */
        if (message.frameId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.frameId);
        /* optional uint64 timestamp = 2; */
        if (message.timestamp !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.timestamp);
        /* optional int32 sensor_id = 3; */
        if (message.sensorId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sensorId);
        /* optional ec.perception.MsgStatus status = 4; */
        if (message.status !== undefined)
            writer.tag(4, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.Header
 */
export const Header = new Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Box2d$Type extends MessageType<Box2d> {
    constructor() {
        super("ec.perception.Box2d", [
            { no: 1, name: "x1", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y1", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "x2", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "y2", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Box2d>): Box2d {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Box2d>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Box2d): Box2d {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float x1 */ 1:
                    message.x1 = reader.float();
                    break;
                case /* optional float y1 */ 2:
                    message.y1 = reader.float();
                    break;
                case /* optional float x2 */ 3:
                    message.x2 = reader.float();
                    break;
                case /* optional float y2 */ 4:
                    message.y2 = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Box2d, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float x1 = 1; */
        if (message.x1 !== undefined)
            writer.tag(1, WireType.Bit32).float(message.x1);
        /* optional float y1 = 2; */
        if (message.y1 !== undefined)
            writer.tag(2, WireType.Bit32).float(message.y1);
        /* optional float x2 = 3; */
        if (message.x2 !== undefined)
            writer.tag(3, WireType.Bit32).float(message.x2);
        /* optional float y2 = 4; */
        if (message.y2 !== undefined)
            writer.tag(4, WireType.Bit32).float(message.y2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.Box2d
 */
export const Box2d = new Box2d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Box3d$Type extends MessageType<Box3d> {
    constructor() {
        super("ec.perception.Box3d", [
            { no: 1, name: "up_x1", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "up_y1", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "up_x2", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "up_y2", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "up_x3", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "up_y3", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "up_x4", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "up_y4", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "bottom_x1", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "bottom_y1", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "bottom_x2", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "bottom_y2", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "bottom_x3", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "bottom_y3", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "bottom_x4", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "bottom_y4", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Box3d>): Box3d {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Box3d>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Box3d): Box3d {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float up_x1 */ 1:
                    message.upX1 = reader.float();
                    break;
                case /* optional float up_y1 */ 2:
                    message.upY1 = reader.float();
                    break;
                case /* optional float up_x2 */ 3:
                    message.upX2 = reader.float();
                    break;
                case /* optional float up_y2 */ 4:
                    message.upY2 = reader.float();
                    break;
                case /* optional float up_x3 */ 5:
                    message.upX3 = reader.float();
                    break;
                case /* optional float up_y3 */ 6:
                    message.upY3 = reader.float();
                    break;
                case /* optional float up_x4 */ 7:
                    message.upX4 = reader.float();
                    break;
                case /* optional float up_y4 */ 8:
                    message.upY4 = reader.float();
                    break;
                case /* optional float bottom_x1 */ 9:
                    message.bottomX1 = reader.float();
                    break;
                case /* optional float bottom_y1 */ 10:
                    message.bottomY1 = reader.float();
                    break;
                case /* optional float bottom_x2 */ 11:
                    message.bottomX2 = reader.float();
                    break;
                case /* optional float bottom_y2 */ 12:
                    message.bottomY2 = reader.float();
                    break;
                case /* optional float bottom_x3 */ 13:
                    message.bottomX3 = reader.float();
                    break;
                case /* optional float bottom_y3 */ 14:
                    message.bottomY3 = reader.float();
                    break;
                case /* optional float bottom_x4 */ 15:
                    message.bottomX4 = reader.float();
                    break;
                case /* optional float bottom_y4 */ 16:
                    message.bottomY4 = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Box3d, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float up_x1 = 1; */
        if (message.upX1 !== undefined)
            writer.tag(1, WireType.Bit32).float(message.upX1);
        /* optional float up_y1 = 2; */
        if (message.upY1 !== undefined)
            writer.tag(2, WireType.Bit32).float(message.upY1);
        /* optional float up_x2 = 3; */
        if (message.upX2 !== undefined)
            writer.tag(3, WireType.Bit32).float(message.upX2);
        /* optional float up_y2 = 4; */
        if (message.upY2 !== undefined)
            writer.tag(4, WireType.Bit32).float(message.upY2);
        /* optional float up_x3 = 5; */
        if (message.upX3 !== undefined)
            writer.tag(5, WireType.Bit32).float(message.upX3);
        /* optional float up_y3 = 6; */
        if (message.upY3 !== undefined)
            writer.tag(6, WireType.Bit32).float(message.upY3);
        /* optional float up_x4 = 7; */
        if (message.upX4 !== undefined)
            writer.tag(7, WireType.Bit32).float(message.upX4);
        /* optional float up_y4 = 8; */
        if (message.upY4 !== undefined)
            writer.tag(8, WireType.Bit32).float(message.upY4);
        /* optional float bottom_x1 = 9; */
        if (message.bottomX1 !== undefined)
            writer.tag(9, WireType.Bit32).float(message.bottomX1);
        /* optional float bottom_y1 = 10; */
        if (message.bottomY1 !== undefined)
            writer.tag(10, WireType.Bit32).float(message.bottomY1);
        /* optional float bottom_x2 = 11; */
        if (message.bottomX2 !== undefined)
            writer.tag(11, WireType.Bit32).float(message.bottomX2);
        /* optional float bottom_y2 = 12; */
        if (message.bottomY2 !== undefined)
            writer.tag(12, WireType.Bit32).float(message.bottomY2);
        /* optional float bottom_x3 = 13; */
        if (message.bottomX3 !== undefined)
            writer.tag(13, WireType.Bit32).float(message.bottomX3);
        /* optional float bottom_y3 = 14; */
        if (message.bottomY3 !== undefined)
            writer.tag(14, WireType.Bit32).float(message.bottomY3);
        /* optional float bottom_x4 = 15; */
        if (message.bottomX4 !== undefined)
            writer.tag(15, WireType.Bit32).float(message.bottomX4);
        /* optional float bottom_y4 = 16; */
        if (message.bottomY4 !== undefined)
            writer.tag(16, WireType.Bit32).float(message.bottomY4);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.Box3d
 */
export const Box3d = new Box3d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoxRef3d$Type extends MessageType<BoxRef3d> {
    constructor() {
        super("ec.perception.BoxRef3d", [
            { no: 1, name: "angle_x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "angle_y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "front_x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "front_y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "rear_x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "rear_y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<BoxRef3d>): BoxRef3d {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BoxRef3d>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoxRef3d): BoxRef3d {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float angle_x */ 1:
                    message.angleX = reader.float();
                    break;
                case /* optional float angle_y */ 2:
                    message.angleY = reader.float();
                    break;
                case /* optional float front_x */ 3:
                    message.frontX = reader.float();
                    break;
                case /* optional float front_y */ 4:
                    message.frontY = reader.float();
                    break;
                case /* optional float rear_x */ 5:
                    message.rearX = reader.float();
                    break;
                case /* optional float rear_y */ 6:
                    message.rearY = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BoxRef3d, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional float angle_x = 1; */
        if (message.angleX !== undefined)
            writer.tag(1, WireType.Bit32).float(message.angleX);
        /* optional float angle_y = 2; */
        if (message.angleY !== undefined)
            writer.tag(2, WireType.Bit32).float(message.angleY);
        /* optional float front_x = 3; */
        if (message.frontX !== undefined)
            writer.tag(3, WireType.Bit32).float(message.frontX);
        /* optional float front_y = 4; */
        if (message.frontY !== undefined)
            writer.tag(4, WireType.Bit32).float(message.frontY);
        /* optional float rear_x = 5; */
        if (message.rearX !== undefined)
            writer.tag(5, WireType.Bit32).float(message.rearX);
        /* optional float rear_y = 6; */
        if (message.rearY !== undefined)
            writer.tag(6, WireType.Bit32).float(message.rearY);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.BoxRef3d
 */
export const BoxRef3d = new BoxRef3d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BBox$Type extends MessageType<BBox> {
    constructor() {
        super("ec.perception.BBox", [
            { no: 1, name: "box_2d", kind: "message", jsonName: "box2d", T: () => Box2d },
            { no: 2, name: "box_3d", kind: "message", jsonName: "box3d", T: () => Box3d },
            { no: 3, name: "box_ref", kind: "message", T: () => BoxRef3d },
            { no: 4, name: "box_score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<BBox>): BBox {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BBox>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BBox): BBox {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ec.perception.Box2d box_2d = 1 [json_name = "box2d"];*/ 1:
                    message.box2D = Box2d.internalBinaryRead(reader, reader.uint32(), options, message.box2D);
                    break;
                case /* optional ec.perception.Box3d box_3d = 2 [json_name = "box3d"];*/ 2:
                    message.box3D = Box3d.internalBinaryRead(reader, reader.uint32(), options, message.box3D);
                    break;
                case /* optional ec.perception.BoxRef3d box_ref */ 3:
                    message.boxRef = BoxRef3d.internalBinaryRead(reader, reader.uint32(), options, message.boxRef);
                    break;
                case /* optional float box_score */ 4:
                    message.boxScore = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BBox, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ec.perception.Box2d box_2d = 1 [json_name = "box2d"]; */
        if (message.box2D)
            Box2d.internalBinaryWrite(message.box2D, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional ec.perception.Box3d box_3d = 2 [json_name = "box3d"]; */
        if (message.box3D)
            Box3d.internalBinaryWrite(message.box3D, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional ec.perception.BoxRef3d box_ref = 3; */
        if (message.boxRef)
            BoxRef3d.internalBinaryWrite(message.boxRef, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional float box_score = 4; */
        if (message.boxScore !== undefined)
            writer.tag(4, WireType.Bit32).float(message.boxScore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.BBox
 */
export const BBox = new BBox$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Letter$Type extends MessageType<Letter> {
    constructor() {
        super("ec.perception.Letter", [
            { no: 1, name: "character_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Letter>): Letter {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Letter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Letter): Letter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 character_id */ 1:
                    message.characterId = reader.int32();
                    break;
                case /* optional float score */ 2:
                    message.score = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Letter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 character_id = 1; */
        if (message.characterId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.characterId);
        /* optional float score = 2; */
        if (message.score !== undefined)
            writer.tag(2, WireType.Bit32).float(message.score);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.Letter
 */
export const Letter = new Letter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LicensePlate$Type extends MessageType<LicensePlate> {
    constructor() {
        super("ec.perception.LicensePlate", [
            { no: 1, name: "license_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "confidence", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "plate_box", kind: "message", T: () => Box2d },
            { no: 4, name: "letters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Letter },
            { no: 5, name: "img_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<LicensePlate>): LicensePlate {
        const message = { letters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LicensePlate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LicensePlate): LicensePlate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string license_id */ 1:
                    message.licenseId = reader.string();
                    break;
                case /* optional float confidence */ 2:
                    message.confidence = reader.float();
                    break;
                case /* optional ec.perception.Box2d plate_box */ 3:
                    message.plateBox = Box2d.internalBinaryRead(reader, reader.uint32(), options, message.plateBox);
                    break;
                case /* repeated ec.perception.Letter letters */ 4:
                    message.letters.push(Letter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bytes img_data */ 5:
                    message.imgData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LicensePlate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string license_id = 1; */
        if (message.licenseId !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.licenseId);
        /* optional float confidence = 2; */
        if (message.confidence !== undefined)
            writer.tag(2, WireType.Bit32).float(message.confidence);
        /* optional ec.perception.Box2d plate_box = 3; */
        if (message.plateBox)
            Box2d.internalBinaryWrite(message.plateBox, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated ec.perception.Letter letters = 4; */
        for (let i = 0; i < message.letters.length; i++)
            Letter.internalBinaryWrite(message.letters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes img_data = 5; */
        if (message.imgData !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.imgData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.LicensePlate
 */
export const LicensePlate = new LicensePlate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Object$Type extends MessageType<Object> {
    constructor() {
        super("ec.perception.Object", [
            { no: 1, name: "track_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "timestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sensor_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "age", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "measurement", kind: "enum", opt: true, T: () => ["ec.perception.MeasurementStatus", MeasurementStatus] },
            { no: 10, name: "category_id", kind: "enum", opt: true, T: () => ["ec.perception.CategoryId", CategoryId] },
            { no: 11, name: "confidence", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "all_confidence", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "bbox", kind: "message", T: () => BBox },
            { no: 30, name: "position_x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 31, name: "position_y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 32, name: "position_score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 40, name: "orientation_type", kind: "enum", opt: true, T: () => ["ec.perception.OrientationType", OrientationType] },
            { no: 41, name: "orientation_score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 50, name: "velocity_x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 51, name: "velocity_y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 52, name: "velocity_score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 61, name: "acceleration_x", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 62, name: "acceleration_y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 63, name: "acceleration_score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 70, name: "length", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 71, name: "width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 72, name: "height", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 73, name: "dimension_score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 80, name: "light_status", kind: "enum", opt: true, T: () => ["ec.perception.CarLightStatus", CarLightStatus] },
            { no: 81, name: "light_score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 90, name: "lane_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 91, name: "lane_id_score", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 100, name: "license_plate", kind: "message", T: () => LicensePlate }
        ]);
    }
    create(value?: PartialMessage<Object>): Object {
        const message = { allConfidence: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Object>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Object): Object {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 track_id */ 1:
                    message.trackId = reader.uint32();
                    break;
                case /* optional uint64 timestamp */ 2:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional int32 sensor_id */ 3:
                    message.sensorId = reader.int32();
                    break;
                case /* optional uint32 age */ 4:
                    message.age = reader.uint32();
                    break;
                case /* optional ec.perception.MeasurementStatus measurement */ 5:
                    message.measurement = reader.int32();
                    break;
                case /* optional ec.perception.CategoryId category_id */ 10:
                    message.categoryId = reader.int32();
                    break;
                case /* optional float confidence */ 11:
                    message.confidence = reader.float();
                    break;
                case /* repeated float all_confidence */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.allConfidence.push(reader.float());
                    else
                        message.allConfidence.push(reader.float());
                    break;
                case /* optional ec.perception.BBox bbox */ 20:
                    message.bbox = BBox.internalBinaryRead(reader, reader.uint32(), options, message.bbox);
                    break;
                case /* optional float position_x */ 30:
                    message.positionX = reader.float();
                    break;
                case /* optional float position_y */ 31:
                    message.positionY = reader.float();
                    break;
                case /* optional float position_score */ 32:
                    message.positionScore = reader.float();
                    break;
                case /* optional ec.perception.OrientationType orientation_type */ 40:
                    message.orientationType = reader.int32();
                    break;
                case /* optional float orientation_score */ 41:
                    message.orientationScore = reader.float();
                    break;
                case /* optional float velocity_x */ 50:
                    message.velocityX = reader.float();
                    break;
                case /* optional float velocity_y */ 51:
                    message.velocityY = reader.float();
                    break;
                case /* optional float velocity_score */ 52:
                    message.velocityScore = reader.float();
                    break;
                case /* optional float acceleration_x */ 61:
                    message.accelerationX = reader.float();
                    break;
                case /* optional float acceleration_y */ 62:
                    message.accelerationY = reader.float();
                    break;
                case /* optional float acceleration_score */ 63:
                    message.accelerationScore = reader.float();
                    break;
                case /* optional float length */ 70:
                    message.length = reader.float();
                    break;
                case /* optional float width */ 71:
                    message.width = reader.float();
                    break;
                case /* optional float height */ 72:
                    message.height = reader.float();
                    break;
                case /* optional float dimension_score */ 73:
                    message.dimensionScore = reader.float();
                    break;
                case /* optional ec.perception.CarLightStatus light_status */ 80:
                    message.lightStatus = reader.int32();
                    break;
                case /* optional float light_score */ 81:
                    message.lightScore = reader.float();
                    break;
                case /* optional int32 lane_id */ 90:
                    message.laneId = reader.int32();
                    break;
                case /* optional float lane_id_score */ 91:
                    message.laneIdScore = reader.float();
                    break;
                case /* optional ec.perception.LicensePlate license_plate */ 100:
                    message.licensePlate = LicensePlate.internalBinaryRead(reader, reader.uint32(), options, message.licensePlate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Object, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 track_id = 1; */
        if (message.trackId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.trackId);
        /* optional uint64 timestamp = 2; */
        if (message.timestamp !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.timestamp);
        /* optional int32 sensor_id = 3; */
        if (message.sensorId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sensorId);
        /* optional uint32 age = 4; */
        if (message.age !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.age);
        /* optional ec.perception.MeasurementStatus measurement = 5; */
        if (message.measurement !== undefined)
            writer.tag(5, WireType.Varint).int32(message.measurement);
        /* optional ec.perception.CategoryId category_id = 10; */
        if (message.categoryId !== undefined)
            writer.tag(10, WireType.Varint).int32(message.categoryId);
        /* optional float confidence = 11; */
        if (message.confidence !== undefined)
            writer.tag(11, WireType.Bit32).float(message.confidence);
        /* repeated float all_confidence = 12; */
        for (let i = 0; i < message.allConfidence.length; i++)
            writer.tag(12, WireType.Bit32).float(message.allConfidence[i]);
        /* optional ec.perception.BBox bbox = 20; */
        if (message.bbox)
            BBox.internalBinaryWrite(message.bbox, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* optional float position_x = 30; */
        if (message.positionX !== undefined)
            writer.tag(30, WireType.Bit32).float(message.positionX);
        /* optional float position_y = 31; */
        if (message.positionY !== undefined)
            writer.tag(31, WireType.Bit32).float(message.positionY);
        /* optional float position_score = 32; */
        if (message.positionScore !== undefined)
            writer.tag(32, WireType.Bit32).float(message.positionScore);
        /* optional ec.perception.OrientationType orientation_type = 40; */
        if (message.orientationType !== undefined)
            writer.tag(40, WireType.Varint).int32(message.orientationType);
        /* optional float orientation_score = 41; */
        if (message.orientationScore !== undefined)
            writer.tag(41, WireType.Bit32).float(message.orientationScore);
        /* optional float velocity_x = 50; */
        if (message.velocityX !== undefined)
            writer.tag(50, WireType.Bit32).float(message.velocityX);
        /* optional float velocity_y = 51; */
        if (message.velocityY !== undefined)
            writer.tag(51, WireType.Bit32).float(message.velocityY);
        /* optional float velocity_score = 52; */
        if (message.velocityScore !== undefined)
            writer.tag(52, WireType.Bit32).float(message.velocityScore);
        /* optional float acceleration_x = 61; */
        if (message.accelerationX !== undefined)
            writer.tag(61, WireType.Bit32).float(message.accelerationX);
        /* optional float acceleration_y = 62; */
        if (message.accelerationY !== undefined)
            writer.tag(62, WireType.Bit32).float(message.accelerationY);
        /* optional float acceleration_score = 63; */
        if (message.accelerationScore !== undefined)
            writer.tag(63, WireType.Bit32).float(message.accelerationScore);
        /* optional float length = 70; */
        if (message.length !== undefined)
            writer.tag(70, WireType.Bit32).float(message.length);
        /* optional float width = 71; */
        if (message.width !== undefined)
            writer.tag(71, WireType.Bit32).float(message.width);
        /* optional float height = 72; */
        if (message.height !== undefined)
            writer.tag(72, WireType.Bit32).float(message.height);
        /* optional float dimension_score = 73; */
        if (message.dimensionScore !== undefined)
            writer.tag(73, WireType.Bit32).float(message.dimensionScore);
        /* optional ec.perception.CarLightStatus light_status = 80; */
        if (message.lightStatus !== undefined)
            writer.tag(80, WireType.Varint).int32(message.lightStatus);
        /* optional float light_score = 81; */
        if (message.lightScore !== undefined)
            writer.tag(81, WireType.Bit32).float(message.lightScore);
        /* optional int32 lane_id = 90; */
        if (message.laneId !== undefined)
            writer.tag(90, WireType.Varint).int32(message.laneId);
        /* optional float lane_id_score = 91; */
        if (message.laneIdScore !== undefined)
            writer.tag(91, WireType.Bit32).float(message.laneIdScore);
        /* optional ec.perception.LicensePlate license_plate = 100; */
        if (message.licensePlate)
            LicensePlate.internalBinaryWrite(message.licensePlate, writer.tag(100, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.Object
 */
export const Object = new Object$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SrcImage$Type extends MessageType<SrcImage> {
    constructor() {
        super("ec.perception.SrcImage", [
            { no: 1, name: "height", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "node_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "fps", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "step", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SrcImage>): SrcImage {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SrcImage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SrcImage): SrcImage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 height */ 1:
                    message.height = reader.uint32();
                    break;
                case /* optional uint32 width */ 2:
                    message.width = reader.uint32();
                    break;
                case /* optional uint32 node_id */ 3:
                    message.nodeId = reader.uint32();
                    break;
                case /* optional float fps */ 4:
                    message.fps = reader.float();
                    break;
                case /* optional uint32 step */ 5:
                    message.step = reader.uint32();
                    break;
                case /* optional bytes data */ 6:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SrcImage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 height = 1; */
        if (message.height !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.height);
        /* optional uint32 width = 2; */
        if (message.width !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.width);
        /* optional uint32 node_id = 3; */
        if (message.nodeId !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.nodeId);
        /* optional float fps = 4; */
        if (message.fps !== undefined)
            writer.tag(4, WireType.Bit32).float(message.fps);
        /* optional uint32 step = 5; */
        if (message.step !== undefined)
            writer.tag(5, WireType.Varint).uint32(message.step);
        /* optional bytes data = 6; */
        if (message.data !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.SrcImage
 */
export const SrcImage = new SrcImage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectMsg$Type extends MessageType<ObjectMsg> {
    constructor() {
        super("ec.perception.ObjectMsg", [
            { no: 1, name: "header", kind: "message", T: () => Header },
            { no: 2, name: "objectlist", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Object },
            { no: 3, name: "objects_num", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "image_data", kind: "message", T: () => SrcImage }
        ]);
    }
    create(value?: PartialMessage<ObjectMsg>): ObjectMsg {
        const message = { objectlist: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectMsg): ObjectMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ec.perception.Header header */ 1:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated ec.perception.Object objectlist */ 2:
                    message.objectlist.push(Object.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 objects_num */ 3:
                    message.objectsNum = reader.int32();
                    break;
                case /* optional ec.perception.SrcImage image_data */ 4:
                    message.imageData = SrcImage.internalBinaryRead(reader, reader.uint32(), options, message.imageData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObjectMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ec.perception.Header header = 1; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ec.perception.Object objectlist = 2; */
        for (let i = 0; i < message.objectlist.length; i++)
            Object.internalBinaryWrite(message.objectlist[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 objects_num = 3; */
        if (message.objectsNum !== undefined)
            writer.tag(3, WireType.Varint).int32(message.objectsNum);
        /* optional ec.perception.SrcImage image_data = 4; */
        if (message.imageData)
            SrcImage.internalBinaryWrite(message.imageData, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ec.perception.ObjectMsg
 */
export const ObjectMsg = new ObjectMsg$Type();
