// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "display_config.proto" (package "autoplt.display.config", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message autoplt.display.config.RadarDisplayConfig
 */
export interface RadarDisplayConfig {
    /**
     * @generated from protobuf field: optional uint32 x_range = 1;
     */
    xRange?: number;
    /**
     * @generated from protobuf field: optional uint32 y_range = 2;
     */
    yRange?: number;
    /**
     * @generated from protobuf field: optional bool display_rcs = 3;
     */
    displayRcs?: boolean;
    /**
     * @generated from protobuf field: optional bool display_rssi = 4;
     */
    displayRssi?: boolean;
}
/**
 * @generated from protobuf message autoplt.display.config.ObjectDisplayConfig
 */
export interface ObjectDisplayConfig {
    /**
     * @generated from protobuf field: optional uint32 x_range = 1;
     */
    xRange?: number;
    /**
     * @generated from protobuf field: optional uint32 y_range = 2;
     */
    yRange?: number;
}
/**
 * @generated from protobuf message autoplt.display.config.WorldToCamera
 */
export interface WorldToCamera {
    /**
     * @generated from protobuf field: optional uint32 camera_id = 1;
     */
    cameraId?: number;
    /**
     * @generated from protobuf field: optional string world_to_camera_file = 2;
     */
    worldToCameraFile?: string;
}
/**
 * @generated from protobuf message autoplt.display.config.SensorResultInfo
 */
export interface SensorResultInfo {
    /**
     * @generated from protobuf field: optional uint32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string result_channel = 2;
     */
    resultChannel?: string;
}
/**
 * @generated from protobuf message autoplt.display.config.DisplayInfoConfig
 */
export interface DisplayInfoConfig {
    /**
     * @generated from protobuf field: optional bool show_fps_ = 1;
     */
    showFps?: boolean;
    /**
     * @generated from protobuf field: optional bool show_object_num_ = 2;
     */
    showObjectNum?: boolean;
    /**
     * @generated from protobuf field: optional bool show_node_name_ = 3;
     */
    showNodeName?: boolean;
}
/**
 * @generated from protobuf message autoplt.display.config.ObjectInfoConfig
 */
export interface ObjectInfoConfig {
    /**
     * @generated from protobuf field: optional bool show_class_ = 1;
     */
    showClass?: boolean;
    /**
     * @generated from protobuf field: optional bool show_pos_ = 2;
     */
    showPos?: boolean;
    /**
     * @generated from protobuf field: optional bool show_vel_ = 3;
     */
    showVel?: boolean;
    /**
     * @generated from protobuf field: optional bool show_location_ = 4;
     */
    showLocation?: boolean;
    /**
     * @generated from protobuf field: optional bool show_plate_ = 5;
     */
    showPlate?: boolean;
}
/**
 * @generated from protobuf message autoplt.display.config.DisplayConfig
 */
export interface DisplayConfig {
    /**
     * @generated from protobuf field: autoplt.display.config.DisplayType display_type = 1;
     */
    displayType: DisplayType;
    /**
     * @generated from protobuf field: optional autoplt.display.config.RadarDisplayConfig display_radar = 2;
     */
    displayRadar?: RadarDisplayConfig;
    /**
     * @generated from protobuf field: optional autoplt.display.config.ObjectDisplayConfig display_obj3d = 3 [json_name = "displayObj3d"];
     */
    displayObj3D?: ObjectDisplayConfig;
    /**
     * @generated from protobuf field: repeated autoplt.display.config.WorldToCamera world_to_camera = 4;
     */
    worldToCamera: WorldToCamera[];
    /**
     * @generated from protobuf field: repeated autoplt.display.config.SensorResultInfo radar_fusion_result = 5;
     */
    radarFusionResult: SensorResultInfo[];
    /**
     * @generated from protobuf field: repeated autoplt.display.config.SensorResultInfo original_image = 6;
     */
    originalImage: SensorResultInfo[];
    /**
     * @generated from protobuf field: repeated autoplt.display.config.SensorResultInfo net_detect_result = 7;
     */
    netDetectResult: SensorResultInfo[];
    /**
     * @generated from protobuf field: repeated autoplt.display.config.SensorResultInfo to3d_detect_result = 8 [json_name = "to3dDetectResult"];
     */
    to3DDetectResult: SensorResultInfo[];
    /**
     * @generated from protobuf field: repeated autoplt.display.config.SensorResultInfo cv_fusion_result = 9;
     */
    cvFusionResult: SensorResultInfo[];
    /**
     * @generated from protobuf field: repeated autoplt.display.config.SensorResultInfo global_fusion_result = 10;
     */
    globalFusionResult: SensorResultInfo[];
    /**
     * @generated from protobuf field: optional string display_config_channel = 11;
     */
    displayConfigChannel?: string;
    /**
     * @generated from protobuf field: optional bool display_bs = 12;
     */
    displayBs?: boolean;
    /**
     * @generated from protobuf field: optional bool save_video = 13;
     */
    saveVideo?: boolean;
    /**
     * @generated from protobuf field: optional float video_fps = 14;
     */
    videoFps?: number;
    /**
     * @generated from protobuf field: optional bool save_result = 15;
     */
    saveResult?: boolean;
    /**
     * @generated from protobuf field: optional string save_result_path = 16;
     */
    saveResultPath?: string;
    /**
     * @generated from protobuf field: optional double save_time_interval = 17;
     */
    saveTimeInterval?: number;
    /**
     * @generated from protobuf field: optional autoplt.display.config.LogLevel display_loglevel = 18;
     */
    displayLoglevel?: LogLevel;
    /**
     * @generated from protobuf field: optional string display_logpath = 19;
     */
    displayLogpath?: string;
    /**
     * @generated from protobuf field: optional string app_name = 20;
     */
    appName?: string;
    /**
     * @generated from protobuf field: optional uint32 multi_camera_lines = 21;
     */
    multiCameraLines?: number;
    /**
     * @generated from protobuf field: optional uint32 multi_camera_index = 22;
     */
    multiCameraIndex?: number;
    /**
     * @generated from protobuf field: optional uint32 image_width = 23;
     */
    imageWidth?: number;
    /**
     * @generated from protobuf field: optional uint32 image_height = 24;
     */
    imageHeight?: number;
    /**
     * @generated from protobuf field: optional autoplt.display.config.DisplayInfoConfig display_info_config = 25;
     */
    displayInfoConfig?: DisplayInfoConfig;
    /**
     * @generated from protobuf field: optional autoplt.display.config.ObjectInfoConfig object_info_config = 26;
     */
    objectInfoConfig?: ObjectInfoConfig;
    /**
     * @generated from protobuf field: optional string rtk_config_file = 27;
     */
    rtkConfigFile?: string;
    /**
     * @generated from protobuf field: optional string fusion_param_file = 28;
     */
    fusionParamFile?: string;
}
/**
 * @generated from protobuf enum autoplt.display.config.DisplayType
 */
export enum DisplayType {
    /**
     * @generated from protobuf enum value: MULTI_LINE_ORIGINAL = 0;
     */
    MULTI_LINE_ORIGINAL = 0,
    /**
     * @generated from protobuf enum value: MULTI_LINE_NET = 1;
     */
    MULTI_LINE_NET = 1,
    /**
     * @generated from protobuf enum value: MULTI_LINE_TO3D = 2;
     */
    MULTI_LINE_TO3D = 2,
    /**
     * @generated from protobuf enum value: MULTI_LINE_CVFUSION = 3;
     */
    MULTI_LINE_CVFUSION = 3,
    /**
     * @generated from protobuf enum value: MULTI_LINE_RADAR = 4;
     */
    MULTI_LINE_RADAR = 4,
    /**
     * @generated from protobuf enum value: MULTI_LINE_GLOBALFUSION = 5;
     */
    MULTI_LINE_GLOBALFUSION = 5
}
/**
 * @generated from protobuf enum autoplt.display.config.LogLevel
 */
export enum LogLevel {
    /**
     * @generated from protobuf enum value: LOGLEVEL_START = 0;
     */
    LOGLEVEL_START = 0,
    /**
     * @generated from protobuf enum value: FETAL = 1;
     */
    FETAL = 1,
    /**
     * @generated from protobuf enum value: ERROR = 2;
     */
    ERROR = 2,
    /**
     * @generated from protobuf enum value: WARNING = 3;
     */
    WARNING = 3,
    /**
     * @generated from protobuf enum value: NOTICE = 4;
     */
    NOTICE = 4,
    /**
     * @generated from protobuf enum value: DEBUG = 5;
     */
    DEBUG = 5,
    /**
     * @generated from protobuf enum value: LOGLEVEL_END = 6;
     */
    LOGLEVEL_END = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class RadarDisplayConfig$Type extends MessageType<RadarDisplayConfig> {
    constructor() {
        super("autoplt.display.config.RadarDisplayConfig", [
            { no: 1, name: "x_range", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "y_range", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "display_rcs", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "display_rssi", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RadarDisplayConfig>): RadarDisplayConfig {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RadarDisplayConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RadarDisplayConfig): RadarDisplayConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 x_range */ 1:
                    message.xRange = reader.uint32();
                    break;
                case /* optional uint32 y_range */ 2:
                    message.yRange = reader.uint32();
                    break;
                case /* optional bool display_rcs */ 3:
                    message.displayRcs = reader.bool();
                    break;
                case /* optional bool display_rssi */ 4:
                    message.displayRssi = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RadarDisplayConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 x_range = 1; */
        if (message.xRange !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.xRange);
        /* optional uint32 y_range = 2; */
        if (message.yRange !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.yRange);
        /* optional bool display_rcs = 3; */
        if (message.displayRcs !== undefined)
            writer.tag(3, WireType.Varint).bool(message.displayRcs);
        /* optional bool display_rssi = 4; */
        if (message.displayRssi !== undefined)
            writer.tag(4, WireType.Varint).bool(message.displayRssi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message autoplt.display.config.RadarDisplayConfig
 */
export const RadarDisplayConfig = new RadarDisplayConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectDisplayConfig$Type extends MessageType<ObjectDisplayConfig> {
    constructor() {
        super("autoplt.display.config.ObjectDisplayConfig", [
            { no: 1, name: "x_range", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "y_range", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ObjectDisplayConfig>): ObjectDisplayConfig {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectDisplayConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectDisplayConfig): ObjectDisplayConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 x_range */ 1:
                    message.xRange = reader.uint32();
                    break;
                case /* optional uint32 y_range */ 2:
                    message.yRange = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObjectDisplayConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 x_range = 1; */
        if (message.xRange !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.xRange);
        /* optional uint32 y_range = 2; */
        if (message.yRange !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.yRange);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message autoplt.display.config.ObjectDisplayConfig
 */
export const ObjectDisplayConfig = new ObjectDisplayConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldToCamera$Type extends MessageType<WorldToCamera> {
    constructor() {
        super("autoplt.display.config.WorldToCamera", [
            { no: 1, name: "camera_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "world_to_camera_file", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorldToCamera>): WorldToCamera {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WorldToCamera>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldToCamera): WorldToCamera {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 camera_id */ 1:
                    message.cameraId = reader.uint32();
                    break;
                case /* optional string world_to_camera_file */ 2:
                    message.worldToCameraFile = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldToCamera, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 camera_id = 1; */
        if (message.cameraId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.cameraId);
        /* optional string world_to_camera_file = 2; */
        if (message.worldToCameraFile !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.worldToCameraFile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message autoplt.display.config.WorldToCamera
 */
export const WorldToCamera = new WorldToCamera$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorResultInfo$Type extends MessageType<SensorResultInfo> {
    constructor() {
        super("autoplt.display.config.SensorResultInfo", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "result_channel", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SensorResultInfo>): SensorResultInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SensorResultInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorResultInfo): SensorResultInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* optional string result_channel */ 2:
                    message.resultChannel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorResultInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* optional string result_channel = 2; */
        if (message.resultChannel !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.resultChannel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message autoplt.display.config.SensorResultInfo
 */
export const SensorResultInfo = new SensorResultInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisplayInfoConfig$Type extends MessageType<DisplayInfoConfig> {
    constructor() {
        super("autoplt.display.config.DisplayInfoConfig", [
            { no: 1, name: "show_fps_", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "show_object_num_", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "show_node_name_", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DisplayInfoConfig>): DisplayInfoConfig {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisplayInfoConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisplayInfoConfig): DisplayInfoConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool show_fps_ */ 1:
                    message.showFps = reader.bool();
                    break;
                case /* optional bool show_object_num_ */ 2:
                    message.showObjectNum = reader.bool();
                    break;
                case /* optional bool show_node_name_ */ 3:
                    message.showNodeName = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisplayInfoConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool show_fps_ = 1; */
        if (message.showFps !== undefined)
            writer.tag(1, WireType.Varint).bool(message.showFps);
        /* optional bool show_object_num_ = 2; */
        if (message.showObjectNum !== undefined)
            writer.tag(2, WireType.Varint).bool(message.showObjectNum);
        /* optional bool show_node_name_ = 3; */
        if (message.showNodeName !== undefined)
            writer.tag(3, WireType.Varint).bool(message.showNodeName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message autoplt.display.config.DisplayInfoConfig
 */
export const DisplayInfoConfig = new DisplayInfoConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectInfoConfig$Type extends MessageType<ObjectInfoConfig> {
    constructor() {
        super("autoplt.display.config.ObjectInfoConfig", [
            { no: 1, name: "show_class_", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "show_pos_", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "show_vel_", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "show_location_", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "show_plate_", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ObjectInfoConfig>): ObjectInfoConfig {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ObjectInfoConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectInfoConfig): ObjectInfoConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool show_class_ */ 1:
                    message.showClass = reader.bool();
                    break;
                case /* optional bool show_pos_ */ 2:
                    message.showPos = reader.bool();
                    break;
                case /* optional bool show_vel_ */ 3:
                    message.showVel = reader.bool();
                    break;
                case /* optional bool show_location_ */ 4:
                    message.showLocation = reader.bool();
                    break;
                case /* optional bool show_plate_ */ 5:
                    message.showPlate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObjectInfoConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool show_class_ = 1; */
        if (message.showClass !== undefined)
            writer.tag(1, WireType.Varint).bool(message.showClass);
        /* optional bool show_pos_ = 2; */
        if (message.showPos !== undefined)
            writer.tag(2, WireType.Varint).bool(message.showPos);
        /* optional bool show_vel_ = 3; */
        if (message.showVel !== undefined)
            writer.tag(3, WireType.Varint).bool(message.showVel);
        /* optional bool show_location_ = 4; */
        if (message.showLocation !== undefined)
            writer.tag(4, WireType.Varint).bool(message.showLocation);
        /* optional bool show_plate_ = 5; */
        if (message.showPlate !== undefined)
            writer.tag(5, WireType.Varint).bool(message.showPlate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message autoplt.display.config.ObjectInfoConfig
 */
export const ObjectInfoConfig = new ObjectInfoConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisplayConfig$Type extends MessageType<DisplayConfig> {
    constructor() {
        super("autoplt.display.config.DisplayConfig", [
            { no: 1, name: "display_type", kind: "enum", T: () => ["autoplt.display.config.DisplayType", DisplayType] },
            { no: 2, name: "display_radar", kind: "message", T: () => RadarDisplayConfig },
            { no: 3, name: "display_obj3d", kind: "message", jsonName: "displayObj3d", T: () => ObjectDisplayConfig },
            { no: 4, name: "world_to_camera", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WorldToCamera },
            { no: 5, name: "radar_fusion_result", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorResultInfo },
            { no: 6, name: "original_image", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorResultInfo },
            { no: 7, name: "net_detect_result", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorResultInfo },
            { no: 8, name: "to3d_detect_result", kind: "message", jsonName: "to3dDetectResult", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorResultInfo },
            { no: 9, name: "cv_fusion_result", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorResultInfo },
            { no: 10, name: "global_fusion_result", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SensorResultInfo },
            { no: 11, name: "display_config_channel", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "display_bs", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "save_video", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "video_fps", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "save_result", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "save_result_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "save_time_interval", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "display_loglevel", kind: "enum", opt: true, T: () => ["autoplt.display.config.LogLevel", LogLevel] },
            { no: 19, name: "display_logpath", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "app_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "multi_camera_lines", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "multi_camera_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "image_width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "image_height", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "display_info_config", kind: "message", T: () => DisplayInfoConfig },
            { no: 26, name: "object_info_config", kind: "message", T: () => ObjectInfoConfig },
            { no: 27, name: "rtk_config_file", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "fusion_param_file", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DisplayConfig>): DisplayConfig {
        const message = { displayType: 0, worldToCamera: [], radarFusionResult: [], originalImage: [], netDetectResult: [], to3DDetectResult: [], cvFusionResult: [], globalFusionResult: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisplayConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisplayConfig): DisplayConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* autoplt.display.config.DisplayType display_type */ 1:
                    message.displayType = reader.int32();
                    break;
                case /* optional autoplt.display.config.RadarDisplayConfig display_radar */ 2:
                    message.displayRadar = RadarDisplayConfig.internalBinaryRead(reader, reader.uint32(), options, message.displayRadar);
                    break;
                case /* optional autoplt.display.config.ObjectDisplayConfig display_obj3d = 3 [json_name = "displayObj3d"];*/ 3:
                    message.displayObj3D = ObjectDisplayConfig.internalBinaryRead(reader, reader.uint32(), options, message.displayObj3D);
                    break;
                case /* repeated autoplt.display.config.WorldToCamera world_to_camera */ 4:
                    message.worldToCamera.push(WorldToCamera.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated autoplt.display.config.SensorResultInfo radar_fusion_result */ 5:
                    message.radarFusionResult.push(SensorResultInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated autoplt.display.config.SensorResultInfo original_image */ 6:
                    message.originalImage.push(SensorResultInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated autoplt.display.config.SensorResultInfo net_detect_result */ 7:
                    message.netDetectResult.push(SensorResultInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated autoplt.display.config.SensorResultInfo to3d_detect_result = 8 [json_name = "to3dDetectResult"];*/ 8:
                    message.to3DDetectResult.push(SensorResultInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated autoplt.display.config.SensorResultInfo cv_fusion_result */ 9:
                    message.cvFusionResult.push(SensorResultInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated autoplt.display.config.SensorResultInfo global_fusion_result */ 10:
                    message.globalFusionResult.push(SensorResultInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string display_config_channel */ 11:
                    message.displayConfigChannel = reader.string();
                    break;
                case /* optional bool display_bs */ 12:
                    message.displayBs = reader.bool();
                    break;
                case /* optional bool save_video */ 13:
                    message.saveVideo = reader.bool();
                    break;
                case /* optional float video_fps */ 14:
                    message.videoFps = reader.float();
                    break;
                case /* optional bool save_result */ 15:
                    message.saveResult = reader.bool();
                    break;
                case /* optional string save_result_path */ 16:
                    message.saveResultPath = reader.string();
                    break;
                case /* optional double save_time_interval */ 17:
                    message.saveTimeInterval = reader.double();
                    break;
                case /* optional autoplt.display.config.LogLevel display_loglevel */ 18:
                    message.displayLoglevel = reader.int32();
                    break;
                case /* optional string display_logpath */ 19:
                    message.displayLogpath = reader.string();
                    break;
                case /* optional string app_name */ 20:
                    message.appName = reader.string();
                    break;
                case /* optional uint32 multi_camera_lines */ 21:
                    message.multiCameraLines = reader.uint32();
                    break;
                case /* optional uint32 multi_camera_index */ 22:
                    message.multiCameraIndex = reader.uint32();
                    break;
                case /* optional uint32 image_width */ 23:
                    message.imageWidth = reader.uint32();
                    break;
                case /* optional uint32 image_height */ 24:
                    message.imageHeight = reader.uint32();
                    break;
                case /* optional autoplt.display.config.DisplayInfoConfig display_info_config */ 25:
                    message.displayInfoConfig = DisplayInfoConfig.internalBinaryRead(reader, reader.uint32(), options, message.displayInfoConfig);
                    break;
                case /* optional autoplt.display.config.ObjectInfoConfig object_info_config */ 26:
                    message.objectInfoConfig = ObjectInfoConfig.internalBinaryRead(reader, reader.uint32(), options, message.objectInfoConfig);
                    break;
                case /* optional string rtk_config_file */ 27:
                    message.rtkConfigFile = reader.string();
                    break;
                case /* optional string fusion_param_file */ 28:
                    message.fusionParamFile = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisplayConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* autoplt.display.config.DisplayType display_type = 1; */
        if (message.displayType !== 0)
            writer.tag(1, WireType.Varint).int32(message.displayType);
        /* optional autoplt.display.config.RadarDisplayConfig display_radar = 2; */
        if (message.displayRadar)
            RadarDisplayConfig.internalBinaryWrite(message.displayRadar, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional autoplt.display.config.ObjectDisplayConfig display_obj3d = 3 [json_name = "displayObj3d"]; */
        if (message.displayObj3D)
            ObjectDisplayConfig.internalBinaryWrite(message.displayObj3D, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated autoplt.display.config.WorldToCamera world_to_camera = 4; */
        for (let i = 0; i < message.worldToCamera.length; i++)
            WorldToCamera.internalBinaryWrite(message.worldToCamera[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated autoplt.display.config.SensorResultInfo radar_fusion_result = 5; */
        for (let i = 0; i < message.radarFusionResult.length; i++)
            SensorResultInfo.internalBinaryWrite(message.radarFusionResult[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated autoplt.display.config.SensorResultInfo original_image = 6; */
        for (let i = 0; i < message.originalImage.length; i++)
            SensorResultInfo.internalBinaryWrite(message.originalImage[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated autoplt.display.config.SensorResultInfo net_detect_result = 7; */
        for (let i = 0; i < message.netDetectResult.length; i++)
            SensorResultInfo.internalBinaryWrite(message.netDetectResult[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated autoplt.display.config.SensorResultInfo to3d_detect_result = 8 [json_name = "to3dDetectResult"]; */
        for (let i = 0; i < message.to3DDetectResult.length; i++)
            SensorResultInfo.internalBinaryWrite(message.to3DDetectResult[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated autoplt.display.config.SensorResultInfo cv_fusion_result = 9; */
        for (let i = 0; i < message.cvFusionResult.length; i++)
            SensorResultInfo.internalBinaryWrite(message.cvFusionResult[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated autoplt.display.config.SensorResultInfo global_fusion_result = 10; */
        for (let i = 0; i < message.globalFusionResult.length; i++)
            SensorResultInfo.internalBinaryWrite(message.globalFusionResult[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional string display_config_channel = 11; */
        if (message.displayConfigChannel !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.displayConfigChannel);
        /* optional bool display_bs = 12; */
        if (message.displayBs !== undefined)
            writer.tag(12, WireType.Varint).bool(message.displayBs);
        /* optional bool save_video = 13; */
        if (message.saveVideo !== undefined)
            writer.tag(13, WireType.Varint).bool(message.saveVideo);
        /* optional float video_fps = 14; */
        if (message.videoFps !== undefined)
            writer.tag(14, WireType.Bit32).float(message.videoFps);
        /* optional bool save_result = 15; */
        if (message.saveResult !== undefined)
            writer.tag(15, WireType.Varint).bool(message.saveResult);
        /* optional string save_result_path = 16; */
        if (message.saveResultPath !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.saveResultPath);
        /* optional double save_time_interval = 17; */
        if (message.saveTimeInterval !== undefined)
            writer.tag(17, WireType.Bit64).double(message.saveTimeInterval);
        /* optional autoplt.display.config.LogLevel display_loglevel = 18; */
        if (message.displayLoglevel !== undefined)
            writer.tag(18, WireType.Varint).int32(message.displayLoglevel);
        /* optional string display_logpath = 19; */
        if (message.displayLogpath !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.displayLogpath);
        /* optional string app_name = 20; */
        if (message.appName !== undefined)
            writer.tag(20, WireType.LengthDelimited).string(message.appName);
        /* optional uint32 multi_camera_lines = 21; */
        if (message.multiCameraLines !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.multiCameraLines);
        /* optional uint32 multi_camera_index = 22; */
        if (message.multiCameraIndex !== undefined)
            writer.tag(22, WireType.Varint).uint32(message.multiCameraIndex);
        /* optional uint32 image_width = 23; */
        if (message.imageWidth !== undefined)
            writer.tag(23, WireType.Varint).uint32(message.imageWidth);
        /* optional uint32 image_height = 24; */
        if (message.imageHeight !== undefined)
            writer.tag(24, WireType.Varint).uint32(message.imageHeight);
        /* optional autoplt.display.config.DisplayInfoConfig display_info_config = 25; */
        if (message.displayInfoConfig)
            DisplayInfoConfig.internalBinaryWrite(message.displayInfoConfig, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* optional autoplt.display.config.ObjectInfoConfig object_info_config = 26; */
        if (message.objectInfoConfig)
            ObjectInfoConfig.internalBinaryWrite(message.objectInfoConfig, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* optional string rtk_config_file = 27; */
        if (message.rtkConfigFile !== undefined)
            writer.tag(27, WireType.LengthDelimited).string(message.rtkConfigFile);
        /* optional string fusion_param_file = 28; */
        if (message.fusionParamFile !== undefined)
            writer.tag(28, WireType.LengthDelimited).string(message.fusionParamFile);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message autoplt.display.config.DisplayConfig
 */
export const DisplayConfig = new DisplayConfig$Type();
